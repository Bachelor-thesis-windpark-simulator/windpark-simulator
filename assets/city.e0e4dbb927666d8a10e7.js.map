{"version":3,"sources":["webpack://future-mobility/./node_modules/events/events.js","webpack://future-mobility/./src/sass/default.scss?bcb6","webpack://future-mobility/./node_modules/vec2/vec2.js","webpack://future-mobility/./src/js/aux/array-2d.js","webpack://future-mobility/./src/js/aux/cardinal-directions.js","webpack://future-mobility/./src/js/aux/config-helpers.js","webpack://future-mobility/./src/js/aux/random.js","webpack://future-mobility/./src/js/aux/show-fatal-error.js","webpack://future-mobility/./src/js/aux/sprite-fader.js","webpack://future-mobility/./src/js/cars/ai-car-driver.js","webpack://future-mobility/./src/js/cars/car-driver.js","webpack://future-mobility/./src/js/cars/car-overlay.js","webpack://future-mobility/./src/js/cars/car-spawner.js","webpack://future-mobility/./src/js/cars/car.js","webpack://future-mobility/./src/js/cars/path-arc.js","webpack://future-mobility/./src/js/cars/path-straight.js","webpack://future-mobility/./src/js/cars/pulled-car-driver.js","webpack://future-mobility/./src/js/cars/road-map.js","webpack://future-mobility/./src/js/cars/road-tile.js","webpack://future-mobility/./src/js/cars/traffic-lights.js","webpack://future-mobility/./src/js/city.js","webpack://future-mobility/./src/js/connection-state-view.js","webpack://future-mobility/./src/js/grid.js","webpack://future-mobility/./src/js/map-view.js","webpack://future-mobility/./src/js/power-up-view-handler.js","webpack://future-mobility/./src/js/power-up-view-mgr.js","webpack://future-mobility/./src/js/power-ups/autonomous-vehicle-handler.js","webpack://future-mobility/./src/js/power-ups/dense-city-handler.js","webpack://future-mobility/./src/js/power-ups/max-speed-handler.js","webpack://future-mobility/./src/js/power-ups/spawn-tram.js","webpack://future-mobility/./src/js/power-ups/traffic-handler.js","webpack://future-mobility/./src/js/power-ups/walkable-city-handler.js","webpack://future-mobility/./src/js/server-socket-connector.js","webpack://future-mobility/./src/js/texture-loader.js","webpack://future-mobility/./src/js/variable-map-overlay.js","webpack://future-mobility/./src/js/variable-map-view.js","webpack://future-mobility/webpack/bootstrap","webpack://future-mobility/webpack/runtime/global","webpack://future-mobility/webpack/runtime/make namespace object","webpack://future-mobility/webpack/runtime/publicPath","webpack://future-mobility/./src/js/main-city.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAA6D,aAAa;AAC1E;AACA,6DAA6D,aAAa;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;AChfA;;;;;;;;;;;ACAA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,2CAA2C,MAAM;AACjD;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,qCAAqC,UAAU,EAAE;;AAEjD;AACA,QAAQ,KAA6B;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACxdD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B,uBAAuB,IAAI;AAC3B,cAAc;AACd;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB,oBAAoB;AACpB,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA,mBAAmB,gBAAgB;AACnC,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,mBAAmB;AACnB;AACA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA,eAAe;AACf,sBAAsB;AACtB;AACA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB,0BAA0B;AAC1B,eAAe;AACf,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf,sBAAsB;AACtB,0BAA0B;AAC1B,cAAc;AACd;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,cAAc;AACjC,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5MA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7CA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;ACVlB;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,wBAAwB,YAAY,EAAE;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;AC7EA,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,OAAO,YAAY,GAAG,mBAAO,CAAC,yCAAa;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;ACxBA,YAAY,mBAAO,CAAC,uEAA4B;AAChD,iBAAiB,mBAAO,CAAC,+CAAa;AACtC,OAAO,aAAa,GAAG,mBAAO,CAAC,6CAAe;AAC9C,OAAO,YAAY,GAAG,mBAAO,CAAC,yCAAa;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrGA;AACA,gBAAgB,mBAAO,CAAC,iDAAiB;AACzC,sBAAsB,mBAAO,CAAC,yDAAkB;AAChD,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;AACzD,gBAAgB,mBAAO,CAAC,6CAAY;;AAEpC;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACnGA,YAAY,mBAAO,CAAC,yCAAa;AACjC,iBAAiB,mBAAO,CAAC,qDAAmB;AAC5C,YAAY,mBAAO,CAAC,uEAA4B;AAChD,OAAO,iCAAiC,GAAG,mBAAO,CAAC,6CAAe;AAClE,kBAAkB,mBAAO,CAAC,iDAAc;;AAExC,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,GAAG,GAAG,QAAQ;AAC7E,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iEAAiE,QAAQ,GAAG,QAAQ;AACpF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrKA;AACA,aAAa,mBAAO,CAAC,yCAAM;AAC3B,kBAAkB,mBAAO,CAAC,iDAAc;AACxC,YAAY,mBAAO,CAAC,uEAA4B;AAChD,iBAAiB,mBAAO,CAAC,+CAAa;AACtC,OAAO,YAAY,GAAG,mBAAO,CAAC,yCAAa;AAC3C,oBAAoB,mBAAO,CAAC,yDAAqB;AACjD,qBAAqB,mBAAO,CAAC,uDAAiB;AAC9C,gBAAgB,mBAAO,CAAC,6CAAY;AACpC,wBAAwB,mBAAO,CAAC,+DAAqB;;AAErD;AACA,iCAAiC;AACjC,iCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7NA,aAAa,mBAAO,CAAC,yCAAM;AAC3B,YAAY,mBAAO,CAAC,uEAA4B;AAChD,iBAAiB,mBAAO,CAAC,+CAAa;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnCA,aAAa,mBAAO,CAAC,yCAAM;AAC3B,iBAAiB,mBAAO,CAAC,+CAAa;AACtC,YAAY,mBAAO,CAAC,uEAA4B;AAChD,gBAAgB,mBAAO,CAAC,yCAAa;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC5BA,kBAAkB,mBAAO,CAAC,iDAAc;;AAExC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,aAAa;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClCA,YAAY,mBAAO,CAAC,uEAA4B;AAChD,gBAAgB,mBAAO,CAAC,iDAAiB;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvCA,aAAa,mBAAO,CAAC,yCAAM;AAC3B,OAAO,YAAY,GAAG,mBAAO,CAAC,yCAAa;;AAE3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,oBAAoB;AAC5B,QAAQ,oBAAoB;AAC5B,QAAQ,oBAAoB;AAC5B,QAAQ,oBAAoB;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,eAAe;AACvB,QAAQ,eAAe;AACvB,QAAQ,eAAe;AACvB,QAAQ,eAAe;AACvB;;AAEA;AACA;;AAEA;;AAEA;AACA,QAAQ,qCAAqC;AAC7C,QAAQ,mBAAmB;AAC3B,QAAQ,qCAAqC;AAC7C,QAAQ,mBAAmB;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3GA,YAAY,mBAAO,CAAC,uEAA4B;;AAEhD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc,GAAG,aAAa;AACjE,aAAa,4BAA4B,GAAG,2BAA2B;AACvE,OAAO;AACP,mCAAmC,cAAc,GAAG,aAAa;AACjE,aAAa,aAAa,GAAG,cAAc;AAC3C;AACA;AACA,yCAAyC,cAAc,GAAG,aAAa;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;ACvEA,aAAa,mBAAO,CAAC,gCAAQ;AAC7B,gBAAgB,mBAAO,CAAC,gDAAgB;;AAExC;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,WAAW,gBAAgB;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrDA,qBAAqB,mBAAO,CAAC,+CAAQ;AACrC,gBAAgB,mBAAO,CAAC,gDAAgB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,cAAc;AACd;AACA;AACA,WAAW,uBAAuB;AAClC;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;;AC9MA;AACA,qBAAqB,mBAAO,CAAC,+CAAQ;AACrC,gBAAgB,mBAAO,CAAC,gDAAgB;AACxC,OAAO,gBAAgB,GAAG,mBAAO,CAAC,4DAAsB;AACxD,qBAAqB,mBAAO,CAAC,8EAAsC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,aAAa;AAC1C,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,qCAAqC,4BAA4B,EAAE;;AAEnE;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qEAAqE,cAAc;AACnF;AACA;;AAEA;AACA;AACA,sEAAsE,cAAc;AACpF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kFAAkF,SAAS;AAC3F;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;ACnNA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;AClDA,2BAA2B,mBAAO,CAAC,mEAA0B;AAC7D,oBAAoB,mBAAO,CAAC,6DAAuB;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1BA,2BAA2B,mBAAO,CAAC,mEAA0B;AAC7D,gBAAgB,mBAAO,CAAC,yCAAa;AACrC,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6DAAuB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,kCAAkC;AAC/D;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D;AACA,6BAA6B,kCAAkC;AAC/D;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1DA,2BAA2B,mBAAO,CAAC,mEAA0B;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvBA,2BAA2B,mBAAO,CAAC,mEAA0B;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjBA,2BAA2B,mBAAO,CAAC,mEAA0B;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;;;;AC3BA,2BAA2B,mBAAO,CAAC,mEAA0B;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxBA;AACA,qBAAqB,mBAAO,CAAC,+CAAQ;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gDAAgD,sBAAsB;AACtE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,sBAAsB;AACpE;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxLA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,uBAAuB,WAAW,EAAE,QAAQ,EAAE;;AAEtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA,0BAA0B,YAAY,IAAI,aAAa;AACvD,KAAK;AACL;;AAEA;AACA,sCAAsC,KAAK;AAC3C;AACA,KAAK;AACL;;AAEA;AACA;AACA,6CAA6C,KAAK,GAAG,IAAI;AACzD;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;AC5DA,wBAAwB,mBAAO,CAAC,0DAAqB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3FA;AACA,gBAAgB,mBAAO,CAAC,gDAAgB;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;UC7CA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA;WACA,CAAC,I;;;;;WCPD;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,kC;;;;;;;;;;ACfA;AACA;AACA,aAAa,mBAAO,CAAC,gCAAQ;AAC7B,gBAAgB,mBAAO,CAAC,wCAAY;AACpC,mBAAO,CAAC,qDAAsB;AAC9B,8BAA8B,mBAAO,CAAC,sEAA2B;AACjE,4BAA4B,mBAAO,CAAC,kEAAyB;AAC7D,uBAAuB,mBAAO,CAAC,gEAAwB;AACvD,mBAAmB,mBAAO,CAAC,wDAAoB;AAC/C,sBAAsB,mBAAO,CAAC,oDAAkB;AAChD,mBAAmB,mBAAO,CAAC,wDAAoB;AAC/C,2BAA2B,mBAAO,CAAC,gEAAwB;AAC3D,uBAAuB,mBAAO,CAAC,0DAAqB;AACpD,uBAAuB,mBAAO,CAAC,0EAA6B;AAC5D,iCAAiC,mBAAO,CAAC,gGAAwC;AACjF,wBAAwB,mBAAO,CAAC,8EAA+B;AAC/D,yBAAyB,mBAAO,CAAC,gEAAwB;AACzD,4BAA4B,mBAAO,CAAC,sFAAmC;AACvE,yBAAyB,mBAAO,CAAC,gFAAgC;;AAEjE,SAAS,uBAA2B,CAAC,WAAW,oBAAoB;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD,qBAA6B;AACjF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,GAAG;AACH;AACA,uDAAuD,uBAA2B,CAAC;AACnF,sDAAsD,uBAA2B,CAAC;AAClF;AACA,GAAG","file":"city.e0e4dbb927666d8a10e7.js","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","// extracted by mini-css-extract-plugin\nexport {};",";(function inject(clean, precision, undef) {\n\n  var isArray = function (a) {\n    return Object.prototype.toString.call(a) === \"[object Array]\";\n  };\n\n  var defined = function(a) {\n    return a !== undef;\n  };\n\n  function Vec2(x, y) {\n    if (!(this instanceof Vec2)) {\n      return new Vec2(x, y);\n    }\n\n    if (isArray(x)) {\n      y = x[1];\n      x = x[0];\n    } else if('object' === typeof x && x) {\n      y = x.y;\n      x = x.x;\n    }\n\n    this.x = Vec2.clean(x || 0);\n    this.y = Vec2.clean(y || 0);\n  }\n\n  Vec2.prototype = {\n    change : function(fn) {\n      if (typeof fn === 'function') {\n        if (this.observers) {\n          this.observers.push(fn);\n        } else {\n          this.observers = [fn];\n        }\n      } else if (this.observers && this.observers.length) {\n        for (var i=this.observers.length-1; i>=0; i--) {\n          this.observers[i](this, fn);\n        }\n      }\n\n      return this;\n    },\n\n    ignore : function(fn) {\n      if (this.observers) {\n        if (!fn) {\n          this.observers = [];\n        } else {\n          var o = this.observers, l = o.length;\n          while(l--) {\n            o[l] === fn && o.splice(l, 1);\n          }\n        }\n      }\n      return this;\n    },\n\n    // set x and y\n    set: function(x, y, notify) {\n      if('number' != typeof x) {\n        notify = y;\n        y = x.y;\n        x = x.x;\n      }\n\n      if(this.x === x && this.y === y) {\n        return this;\n      }\n\n      var orig = null;\n      if (notify !== false && this.observers && this.observers.length) {\n        orig = this.clone();\n      }\n\n      this.x = Vec2.clean(x);\n      this.y = Vec2.clean(y);\n\n      if(notify !== false) {\n        return this.change(orig);\n      }\n    },\n\n    // reset x and y to zero\n    zero : function() {\n      return this.set(0, 0);\n    },\n\n    // return a new vector with the same component values\n    // as this one\n    clone : function() {\n      return new (this.constructor)(this.x, this.y);\n    },\n\n    // negate the values of this vector\n    negate : function(returnNew) {\n      if (returnNew) {\n        return new (this.constructor)(-this.x, -this.y);\n      } else {\n        return this.set(-this.x, -this.y);\n      }\n    },\n\n    // Add the incoming `vec2` vector to this vector\n    add : function(x, y, returnNew) {\n\n      if (typeof x != 'number') {\n        returnNew = y;\n        if (isArray(x)) {\n          y = x[1];\n          x = x[0];\n        } else {\n          y = x.y;\n          x = x.x;\n        }\n      }\n\n      x += this.x;\n      y += this.y;\n\n\n      if (!returnNew) {\n        return this.set(x, y);\n      } else {\n        // Return a new vector if `returnNew` is truthy\n        return new (this.constructor)(x, y);\n      }\n    },\n\n    // Subtract the incoming `vec2` from this vector\n    subtract : function(x, y, returnNew) {\n      if (typeof x != 'number') {\n        returnNew = y;\n        if (isArray(x)) {\n          y = x[1];\n          x = x[0];\n        } else {\n          y = x.y;\n          x = x.x;\n        }\n      }\n\n      x = this.x - x;\n      y = this.y - y;\n\n      if (!returnNew) {\n        return this.set(x, y);\n      } else {\n        // Return a new vector if `returnNew` is truthy\n        return new (this.constructor)(x, y);\n      }\n    },\n\n    // Multiply this vector by the incoming `vec2`\n    multiply : function(x, y, returnNew) {\n      if (typeof x != 'number') {\n        returnNew = y;\n        if (isArray(x)) {\n          y = x[1];\n          x = x[0];\n        } else {\n          y = x.y;\n          x = x.x;\n        }\n      } else if (typeof y != 'number') {\n        returnNew = y;\n        y = x;\n      }\n\n      x *= this.x;\n      y *= this.y;\n\n      if (!returnNew) {\n        return this.set(x, y);\n      } else {\n        return new (this.constructor)(x, y);\n      }\n    },\n\n    // Rotate this vector. Accepts a `Rotation` or angle in radians.\n    //\n    // Passing a truthy `inverse` will cause the rotation to\n    // be reversed.\n    //\n    // If `returnNew` is truthy, a new\n    // `Vec2` will be created with the values resulting from\n    // the rotation. Otherwise the rotation will be applied\n    // to this vector directly, and this vector will be returned.\n    rotate : function(r, inverse, returnNew) {\n      var\n      x = this.x,\n      y = this.y,\n      cos = Math.cos(r),\n      sin = Math.sin(r),\n      rx, ry;\n\n      inverse = (inverse) ? -1 : 1;\n\n      rx = cos * x - (inverse * sin) * y;\n      ry = (inverse * sin) * x + cos * y;\n\n      if (returnNew) {\n        return new (this.constructor)(rx, ry);\n      } else {\n        return this.set(rx, ry);\n      }\n    },\n\n    // Calculate the length of this vector\n    length : function() {\n      var x = this.x, y = this.y;\n      return Math.sqrt(x * x + y * y);\n    },\n\n    // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).\n    lengthSquared : function() {\n      var x = this.x, y = this.y;\n      return x*x+y*y;\n    },\n\n    // Return the distance betwen this `Vec2` and the incoming vec2 vector\n    // and return a scalar\n    distance : function(vec2) {\n      var x = this.x - vec2.x;\n      var y = this.y - vec2.y;\n      return Math.sqrt(x*x + y*y);\n    },\n\n    // Given Array of Vec2, find closest to this Vec2.\n    nearest : function(others) {\n      var\n      shortestDistance = Number.MAX_VALUE,\n      nearest = null,\n      currentDistance;\n\n      for (var i = others.length - 1; i >= 0; i--) {\n        currentDistance = this.distance(others[i]);\n        if (currentDistance <= shortestDistance) {\n          shortestDistance = currentDistance;\n          nearest = others[i];\n        }\n      }\n\n      return nearest;\n    },\n\n    // Convert this vector into a unit vector.\n    // Returns the length.\n    normalize : function(returnNew) {\n      var length = this.length();\n\n      // Collect a ratio to shrink the x and y coords\n      var invertedLength = (length < Number.MIN_VALUE) ? 0 : 1/length;\n\n      if (!returnNew) {\n        // Convert the coords to be greater than zero\n        // but smaller than or equal to 1.0\n        return this.set(this.x * invertedLength, this.y * invertedLength);\n      } else {\n        return new (this.constructor)(this.x * invertedLength, this.y * invertedLength);\n      }\n    },\n\n    // Determine if another `Vec2`'s components match this one's\n    // also accepts 2 scalars\n    equal : function(v, w) {\n      if (typeof v != 'number') {\n        if (isArray(v)) {\n          w = v[1];\n          v = v[0];\n        } else {\n          w = v.y;\n          v = v.x;\n        }\n      }\n\n      return (Vec2.clean(v) === this.x && Vec2.clean(w) === this.y);\n    },\n\n    // Return a new `Vec2` that contains the absolute value of\n    // each of this vector's parts\n    abs : function(returnNew) {\n      var x = Math.abs(this.x), y = Math.abs(this.y);\n\n      if (returnNew) {\n        return new (this.constructor)(x, y);\n      } else {\n        return this.set(x, y);\n      }\n    },\n\n    // Return a new `Vec2` consisting of the smallest values\n    // from this vector and the incoming\n    //\n    // When returnNew is truthy, a new `Vec2` will be returned\n    // otherwise the minimum values in either this or `v` will\n    // be applied to this vector.\n    min : function(v, returnNew) {\n      var\n      tx = this.x,\n      ty = this.y,\n      vx = v.x,\n      vy = v.y,\n      x = tx < vx ? tx : vx,\n      y = ty < vy ? ty : vy;\n\n      if (returnNew) {\n        return new (this.constructor)(x, y);\n      } else {\n        return this.set(x, y);\n      }\n    },\n\n    // Return a new `Vec2` consisting of the largest values\n    // from this vector and the incoming\n    //\n    // When returnNew is truthy, a new `Vec2` will be returned\n    // otherwise the minimum values in either this or `v` will\n    // be applied to this vector.\n    max : function(v, returnNew) {\n      var\n      tx = this.x,\n      ty = this.y,\n      vx = v.x,\n      vy = v.y,\n      x = tx > vx ? tx : vx,\n      y = ty > vy ? ty : vy;\n\n      if (returnNew) {\n        return new (this.constructor)(x, y);\n      } else {\n        return this.set(x, y);\n      }\n    },\n\n    // Clamp values into a range.\n    // If this vector's values are lower than the `low`'s\n    // values, then raise them.  If they are higher than\n    // `high`'s then lower them.\n    //\n    // Passing returnNew as true will cause a new Vec2 to be\n    // returned.  Otherwise, this vector's values will be clamped\n    clamp : function(low, high, returnNew) {\n      var ret = this.min(high, true).max(low);\n      if (returnNew) {\n        return ret;\n      } else {\n        return this.set(ret.x, ret.y);\n      }\n    },\n\n    // Perform linear interpolation between two vectors\n    // amount is a decimal between 0 and 1\n    lerp : function(vec, amount, returnNew) {\n      return this.add(vec.subtract(this, true).multiply(amount), returnNew);\n    },\n\n    // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n    skew : function(returnNew) {\n      if (!returnNew) {\n        return this.set(-this.y, this.x)\n      } else {\n        return new (this.constructor)(-this.y, this.x);\n      }\n    },\n\n    // calculate the dot product between\n    // this vector and the incoming\n    dot : function(b) {\n      return Vec2.clean(this.x * b.x + b.y * this.y);\n    },\n\n    // calculate the perpendicular dot product between\n    // this vector and the incoming\n    perpDot : function(b) {\n      return Vec2.clean(this.x * b.y - this.y * b.x);\n    },\n\n    // Determine the angle between two vec2s\n    angleTo : function(vec) {\n      return Math.atan2(this.perpDot(vec), this.dot(vec));\n    },\n\n    // Divide this vector's components by a scalar\n    divide : function(x, y, returnNew) {\n      if (typeof x != 'number') {\n        returnNew = y;\n        if (isArray(x)) {\n          y = x[1];\n          x = x[0];\n        } else {\n          y = x.y;\n          x = x.x;\n        }\n      } else if (typeof y != 'number') {\n        returnNew = y;\n        y = x;\n      }\n\n      if (x === 0 || y === 0) {\n        throw new Error('division by zero')\n      }\n\n      if (isNaN(x) || isNaN(y)) {\n        throw new Error('NaN detected');\n      }\n\n      if (returnNew) {\n        return new (this.constructor)(this.x / x, this.y / y);\n      }\n\n      return this.set(this.x / x, this.y / y);\n    },\n\n    isPointOnLine : function(start, end) {\n      return (start.y - this.y) * (start.x - end.x) ===\n             (start.y - end.y) * (start.x - this.x);\n    },\n\n    toArray: function() {\n      return [this.x, this.y];\n    },\n\n    fromArray: function(array) {\n      return this.set(array[0], array[1]);\n    },\n    toJSON: function () {\n      return {x: this.x, y: this.y};\n    },\n    toString: function() {\n      return '(' + this.x + ', ' + this.y + ')';\n    },\n    constructor : Vec2\n  };\n\n  Vec2.fromArray = function(array, ctor) {\n    return new (ctor || Vec2)(array[0], array[1]);\n  };\n\n  // Floating point stability\n  Vec2.precision = precision || 8;\n  var p = Math.pow(10, Vec2.precision);\n\n  Vec2.clean = clean || function(val) {\n    if (isNaN(val)) {\n      throw new Error('NaN detected');\n    }\n\n    if (!isFinite(val)) {\n      throw new Error('Infinity detected');\n    }\n\n    if(Math.round(val) === val) {\n      return val;\n    }\n\n    return Math.round(val * p)/p;\n  };\n\n  Vec2.inject = inject;\n\n  if(!clean) {\n    Vec2.fast = inject(function (k) { return k; });\n\n    // Expose, but also allow creating a fresh Vec2 subclass.\n    if (typeof module !== 'undefined' && typeof module.exports == 'object') {\n      module.exports = Vec2;\n    } else {\n      window.Vec2 = window.Vec2 || Vec2;\n    }\n  }\n  return Vec2;\n})();\n","/**\n * This class provides helper functions to work with 2D arrays.\n * (arrays of arrays)\n */\nclass Array2D {\n  /**\n   * Create and initialize a 2D Array\n   *\n   * @param width {number} Number of columns (inner arrays size)\n   * @param height {number} Number of rows (outer array size)\n   * @param initValue {any} Initial value for inner array items\n   * @return {any[][]}\n   */\n  static create(width, height, initValue = 0) {\n    const rows = [];\n    for (let i = 0; i < height; i += 1) {\n      const row = [];\n      for (let j = 0; j < width; j += 1) {\n        row[j] = initValue;\n      }\n      rows.push(row);\n    }\n    return rows;\n  }\n\n  /**\n   * Creates a 2D array from a 1D array in cells[y * width + x] format\n   *\n   * @param width {number}\n   * @param height {number}\n   * @param cells {any[]}\n   */\n  static fromFlat(width, height, cells) {\n    const answer = Array2D.create(width, height);\n    for (let x = 0; x < width; x += 1) {\n      for (let y = 0; y < height; y += 1) {\n        answer[y][x] = cells[y * width + x];\n      }\n    }\n    return answer;\n  }\n\n  /**\n   * Returns a 1D array with the flattened contents of the 2D array\n   * @return {*[]}\n   */\n  static flatten(a) {\n    const items = [];\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        items.push(a[y][x]);\n      }\n    }\n    return items;\n  }\n\n  /**\n   * Returns true if the argument is an array of arrays and every inner\n   * array has the same length.\n   *\n   * @param a {any[][]}\n   * @return {boolean}\n   */\n  static isValid(a) {\n    return Array.isArray(a) && a.length > 0\n      && Array.isArray(a[0]) && a[0].length > 0\n      && a.every(row => row.length === a[0].length);\n  }\n\n  /**\n   * Returns the size of a 2D array as [width, height]\n   *\n   * Assumes the argument is a valid 2D Array.\n   *\n   * @param a {any[][]}\n   * @return {number[]}\n   */\n  static size(a) {\n    return [a[0].length, a.length];\n  }\n\n  /**\n   * Clones the 2D Array.\n   *\n   * Assumes the argument is a valid 2D Array. The items in the 2D\n   * array are not deep copied, only the outer and inner arrays.\n   *\n   * @param a {any[][]}\n   * @return {any[][]}\n   */\n  static clone(a) {\n    return a.map(row => Array.from(row));\n  }\n\n  /**\n   * Copies the contents of a 2D array into another.\n   *\n   * Assumes the arguments are valid 2D arrays with the same size.\n   *\n   * @param src {any[][]}\n   * @param dest {any[][]}\n   */\n  static copy(src, dest) {\n    for (let i = 0; i < src.length; i += 1) {\n      for (let j = 0; j < src[i].length; j += 1) {\n        // eslint-disable-next-line no-param-reassign\n        dest[i][j] = src[i][j];\n      }\n    }\n  }\n\n  /**\n   * Sets all cells to a fixed value\n   *\n   * @param a {any[][]}\n   * @param value {any}\n   */\n  static setAll(a, value) {\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        a[y][x] = value;\n      }\n    }\n  }\n\n  /**\n   * Returns all items as a flat array of [x, y, value] arrays.\n   *\n   * @param a {any[][]}\n   * @return {[number, number, any][]}\n   */\n  static items(a) {\n    const items = [];\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        items.push([x, y, a[y][x]]);\n      }\n    }\n    return items;\n  }\n\n  /**\n   * @callback coordinateCallback\n   * @param x {number}\n   * @param y {number}\n   * @return {any}\n   */\n  /**\n   * Fills the items in the array with the result of a callback\n   *\n   * @param a {any[][]}\n   * @param callback {coordinateCallback}\n   */\n  static fill(a, callback) {\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        a[y][x] = callback(x, y);\n      }\n    }\n  }\n\n  /**\n   * @callback reduceCallback\n   * @param accumulator {any}\n   * @param currentValue {any}\n   * @param x {number}\n   * @param y {number}\n   */\n  /**\n   *\n   * @param a {any[][]}\n   * @param callback {reduceCallback}\n   * @param initialValue {any}\n   * @return {any}\n   */\n  static reduce(a, callback, initialValue) {\n    let accumulator = initialValue;\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        accumulator = callback(accumulator, a[y][x], x, y);\n      }\n    }\n    return accumulator;\n  }\n\n  static forEach(a, callback) {\n    for (let y = 0; y < a.length; y += 1) {\n      for (let x = 0; x < a[y].length; x += 1) {\n        callback(a[y][x], x, y);\n      }\n    }\n  }\n\n  static zip(a, b, callback) {\n    const yMax = Math.min(a.length, b.length);\n    for (let y = 0; y < yMax; y += 1) {\n      const xMax = Math.min(a[y].length, b[y].length);\n      for (let x = 0; x < xMax; x += 1) {\n        callback(a[y][x], b[y][x], x, y);\n      }\n    }\n  }\n}\n\nmodule.exports = Array2D;\n","const all = ['N', 'E', 'S', 'W'];\n\nfunction opposite(direction) {\n  return {\n    N: 'S', E: 'W', S: 'N', W: 'E',\n  }[direction];\n}\n\nfunction ccw(direction) {\n  return {\n    N: 'W', E: 'N', S: 'E', W: 'S',\n  }[direction];\n}\n\nfunction cw(direction) {\n  return {\n    N: 'E', E: 'S', S: 'W', W: 'N',\n  }[direction];\n}\n\nfunction asVector(direction) {\n  return {\n    N: [0, -1], E: [1, 0], S: [0, 1], W: [-1, 0],\n  }[direction];\n}\n\nfunction asAngle(direction) {\n  return {\n    N: Math.PI, E: Math.PI * 1.5, S: 0, W: Math.PI * 0.5,\n  }[direction];\n}\n\nfunction adjCoords(x, y, direction) {\n  const [dx, dy] = asVector(direction);\n  return [x + dx, y + dy];\n}\n\nmodule.exports = {\n  all,\n  opposite,\n  ccw,\n  cw,\n  asVector,\n  asAngle,\n  adjCoords,\n};\n","function getTileTypeId(config, type) {\n  const entry = Object.entries(config.tileTypes).find(([, props]) => props.type === type);\n  return entry ? Number(entry[0]) : null;\n}\n\nfunction getTileType(config, type) {\n  const entry = Object.entries(config.tileTypes).find(([, props]) => props.type === type);\n  return entry ? entry[1] : null;\n}\n\nmodule.exports = { getTileTypeId, getTileType };\n","/**\n * Create a function that picks an element from a set where each has a probability weight.\n *\n * The returned function can be called repeatedly to pick random elements.\n *\n * @param {[any, number]} weightedOptions\n *  An array of options. Each option is an array where the first\n *  item is the element, and the second is the weight.\n * @return {function(): any}\n *  Returns a function that returns a random element.\n */\nfunction weightedRandomizer(weightedOptions) {\n  let last = 0;\n  const ranges = new Array(weightedOptions.length);\n  // ranges = [from, to, value]\n  weightedOptions.forEach(([value, weight], i) => {\n    ranges[i] = [last, last + weight, value];\n    last += weight;\n  });\n\n  return () => {\n    const rndP = Math.random() * last;\n    return ranges.find(([min, max]) => rndP > min && rndP < max)[2];\n  };\n}\n\nfunction randomItem(items) {\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nmodule.exports = {\n  weightedRandomizer,\n  randomItem,\n};\n","function showFatalError(text, error) {\n  $('<div></div>')\n    .addClass('fatal-error')\n    .append($('<div></div>')\n      .addClass('fatal-error-text')\n      .html(text))\n    .append($('<div></div>')\n      .addClass('fatal-error-details')\n      .html(error.message))\n    .appendTo('body');\n\n  $('html').addClass('with-fatal-error');\n}\n\nmodule.exports = showFatalError;\n","class SpriteFader {\n  constructor(sprite) {\n    this.sprite = sprite;\n    this.callback = null;\n    this.duration = null;\n    this.startAlpha = null;\n    this.endAlpha = null;\n\n    this.visible = this.sprite.alpha !== 0;\n    this.isFading = false;\n  }\n\n  fadeIn(callback = null, duration = SpriteFader.DEFAULT_DURATION) {\n    if (!this.visible) {\n      this.visible = true;\n      this.startFade(0, 1, duration, callback);\n    }\n    if (callback) {\n      this.setCallback(callback);\n    }\n  }\n\n  fadeOut(callback = null, duration = SpriteFader.DEFAULT_DURATION) {\n    if (this.visible) {\n      this.visible = false;\n      this.startFade(1, 0, duration, callback);\n    }\n    if (callback) {\n      this.setCallback(callback);\n    }\n  }\n\n  setCallback(callback) {\n    if (this.isFading) {\n      this.callback = callback;\n    } else {\n      setTimeout(() => { callback(); }, 0);\n    }\n  }\n\n  startFade(startAlpha, endAlpha, duration = SpriteFader.DEFAULT_DURATION, callback = null) {\n    this.callback = callback;\n    this.startAlpha = startAlpha;\n    this.endAlpha = endAlpha;\n    this.duration = duration;\n    this.isFading = true;\n    this.timer = 0;\n  }\n\n  onFadeEnd() {\n    if (this.callback) {\n      setTimeout(() => {\n        this.callback();\n        this.callback = null;\n      }, 0);\n    }\n    this.isFading = false;\n    this.startAlpha = null;\n    this.endAlpha = null;\n    this.duration = null;\n    this.timer = 0;\n  }\n\n  animate(time) {\n    if (this.isFading) {\n      this.timer = Math.min(this.duration, this.timer + time);\n      this.sprite.alpha = this.startAlpha\n        + (this.endAlpha - this.startAlpha) * (this.timer / this.duration);\n      if (this.timer === this.duration) {\n        this.onFadeEnd();\n      }\n    }\n  }\n}\n\nSpriteFader.DEFAULT_DURATION = 20;\n\nmodule.exports = SpriteFader;\n","const CarDriver = require('./car-driver');\nconst { TILE_SIZE } = require('../map-view');\n\nconst LIGHT_CHANGE_DELAY = 500;\n// The closest a car can get to another\nconst SAFE_DISTANCE = TILE_SIZE / 36;\n// Distance at which a car begins to slow down when there's another in front\nconst SLOWDOWN_DISTANCE = TILE_SIZE / 18;\n\nclass AiCarDriver extends CarDriver {\n  constructor(car) {\n    super(car);\n    this.safeDistance = SAFE_DISTANCE;\n    this.slowdownDistance = SLOWDOWN_DISTANCE;\n    this.carSpeedDeviation = 0;\n  }\n\n  onGreenLight() {\n    setTimeout(() => {\n      this.inRedLight = false;\n    }, LIGHT_CHANGE_DELAY);\n  }\n}\n\nmodule.exports = AiCarDriver;\n","const Dir = require('../aux/cardinal-directions');\nconst RoadTile = require('./road-tile');\nconst { randomItem } = require('../aux/random');\nconst { TILE_SIZE } = require('../map-view');\n\nconst LIGHT_CHANGE_DELAY = [300, 800];\n// The closest a car can get to another\nconst SAFE_DISTANCE = TILE_SIZE / 20;\n// Distance at which a car begins to slow down when there's another in front\nconst SLOWDOWN_DISTANCE = TILE_SIZE / 3;\n\nclass CarDriver {\n  constructor(car) {\n    this.car = car;\n    this.carDistanceFactor = 1 + Math.random() * 0.6;\n    this.carSpeedDeviation = Math.random() * 0.2 - 0.1;\n    this.carSpeedFactor = 1 + (Math.random() * 0.3 - 0.15);\n    this.safeDistance = SAFE_DISTANCE * this.carDistanceFactor;\n    this.slowdownDistance = SLOWDOWN_DISTANCE * this.carDistanceFactor;\n    this.inRedLight = false;\n  }\n\n  getMaxSpeed() {\n    const base = Math.min(this.car.maxSpeed, this.car.overlay.cityMaxSpeed);\n    return (this.car.lane === RoadTile.OUTER_LANE)\n      ? base * 0.8 * this.carSpeedFactor\n      : base * this.carSpeedFactor;\n  }\n\n  chooseExitSide(tileX, tileY, entrySide) {\n    // Select the direction based on road availability\n    const options = [];\n\n    // If it's possible to go forward, add the option\n    if (this.car.overlay.roads.hasAdjRoad(tileX, tileY, Dir.opposite(entrySide))) {\n      // Add it three times to make it more likely than turning\n      options.push(Dir.opposite(entrySide));\n      options.push(Dir.opposite(entrySide));\n      options.push(Dir.opposite(entrySide));\n    }\n    // If it's possible to turn right, add the option\n    if ((options.length === 0 || this.car.lane === RoadTile.OUTER_LANE)\n      && this.car.overlay.roads.hasAdjRoad(tileX, tileY, Dir.ccw(entrySide))) {\n      options.push(Dir.ccw(entrySide));\n    }\n    // If it's not possible to go forward or turn right,\n    // turn left if possible.\n    if (options.length === 0\n      && this.car.overlay.roads.hasAdjRoad(tileX, tileY, Dir.cw(entrySide))) {\n      options.push(Dir.cw(entrySide));\n    }\n\n    // Randomly select one of the possible directions\n    // return null if there's no way to go\n    return randomItem(options) || null;\n  }\n\n  onGreenLight() {\n    const [minDelay, maxDelay] = LIGHT_CHANGE_DELAY;\n    setTimeout(() => {\n      this.inRedLight = false;\n    }, minDelay + Math.random() * (maxDelay - minDelay));\n  }\n\n  onRedLight() {\n    this.inRedLight = true;\n  }\n\n  adjustCarSpeed() {\n    const position = this.car.getSpritePosition();\n    const carInFront = this.car.overlay.getCarInFront(this.car);\n    const maxSpeed = this.getMaxSpeed();\n    if (carInFront) {\n      const overlapDistance = this.car.sprite.height / 2 + carInFront.sprite.height / 2;\n      const distanceToCarInFront = carInFront\n        .getSpritePosition()\n        .distance(position) - overlapDistance;\n      if (distanceToCarInFront <= this.safeDistance) {\n        this.car.speed = 0;\n      } else if (distanceToCarInFront <= this.slowdownDistance) {\n        // Decelerate to maintain the safe distance\n        this.car.speed = maxSpeed * (1 - this.safeDistance / distanceToCarInFront);\n      } else if (this.car.speed < maxSpeed) {\n        // Accelerate up to the maxSpeed\n        this.car.speed = Math.min(this.car.speed + maxSpeed / 5, maxSpeed);\n      }\n    } else if (this.car.speed < maxSpeed) {\n      // Accelerate up to the maxSpeed\n      this.car.speed = Math.min(this.car.speed + maxSpeed / 5, maxSpeed);\n    }\n\n    if (this.car.speed > maxSpeed) {\n      this.car.speed = this.car.speed * 0.9;\n    }\n\n    if (this.inRedLight && this.car.speed > 0) {\n      this.car.speed = 0;\n    }\n  }\n}\n\nmodule.exports = CarDriver;\n","/* globals PIXI */\nconst Array2D = require('../aux/array-2d');\nconst TrafficLights = require('./traffic-lights');\nconst { getTileTypeId } = require('../aux/config-helpers');\nconst RoadMap = require('./road-map');\n\nclass CarOverlay {\n  constructor(mapView, config, textures, options = {}) {\n    this.mapView = mapView;\n    this.config = config;\n    this.textures = textures;\n    this.city = this.mapView.city;\n    this.roads = new RoadMap(this.city.map, getTileTypeId(config, 'road'));\n    this.cityMaxSpeed = 0.7;\n\n    this.options = Object.assign({}, CarOverlay.defaultOptions, options);\n\n    this.displayObject = new PIXI.Container();\n    this.displayObject.width = this.mapView.width;\n    this.displayObject.height = this.mapView.height;\n    this.displayObject.x = 0;\n    this.displayObject.y = 0;\n    this.displayObject.zIndex = 100;\n    this.mapView.addOverlay(this.displayObject);\n\n    this.roadTileId = getTileTypeId(config, 'road');\n\n    this.cars = [];\n    this.carsByTile = Array2D.create(this.city.map.width, this.city.map.height, null);\n    Array2D.fill(this.carsByTile, () => []);\n\n    this.trafficLights = Array2D.create(this.city.map.width, this.city.map.height, null);\n    Array2D.fill(this.trafficLights, () => new TrafficLights());\n  }\n\n  addCar(aCar) {\n    this.cars.push(aCar);\n    this.displayObject.addChild(aCar.sprite);\n  }\n\n  destroyCar(aCar) {\n    this.cars.splice(this.cars.indexOf(aCar), 1);\n    this.displayObject.removeChild(aCar);\n    aCar.destroy();\n  }\n\n  onCarEnterTile(car, tileX, tileY) {\n    this.carsByTile[tileY][tileX].push(car);\n    this.trafficLights[tileY][tileX].onCarEnter(car);\n  }\n\n  onCarExitTile(car, tileX, tileY) {\n    this.carsByTile[tileY][tileX].splice(this.carsByTile[tileY][tileX].indexOf(car), 1);\n    this.trafficLights[tileY][tileX].onCarExit(car);\n  }\n\n  onCarExitMap(aCar) {\n    this.destroyCar(aCar);\n  }\n\n  animate(time) {\n    this.cars.forEach(car => car.animate(time));\n  }\n\n  getCarsInTile(x, y) {\n    return this.city.map.isValidCoords(x, y) ? this.carsByTile[y][x] : [];\n  }\n\n  getCarsAround(car) {\n    const tiles = [[car.tile.x, car.tile.y]].concat(\n      this.city.map.adjacentCells(car.tile.x, car.tile.y)\n    );\n    return [].concat(...tiles.map(([x, y]) => this.getCarsInTile(x, y)))\n      .filter(other => car !== other);\n  }\n\n  getCarInFront(car) {\n    // The car in front can be a car on the same tile,\n    // with the same lane and entrySide,\n    // but the minimum *larger* progress...\n    return this.getCarsInTile(car.tile.x, car.tile.y)\n      .filter(other => car !== other && other.lane === car.lane\n        && other.entrySide === car.entrySide && other.path.progress > car.path.progress)\n      .sort((a, b) => a.path.progress - b.path.progress)\n      .shift()\n    // ... or a car in the next tile, with the same lane and\n    // entry side, and the minimum progress\n      || this.getCarsInTile(...car.getNextTile())\n        .filter(other => car !== other && other.lane === car.lane\n          && other.entrySide === car.getNextEntry())\n        .sort((a, b) => a.path.progress - b.path.progress)\n        .shift();\n  }\n}\n\nCarOverlay.defaultOptions = {\n  maxLifetime: true, // If true cars will be killed after some time\n};\n\nmodule.exports = CarOverlay;\n","const Car = require('../cars/car');\nconst RoadTile = require('../cars/road-tile');\nconst Dir = require('../aux/cardinal-directions');\nconst { randomItem, weightedRandomizer } = require('../aux/random');\nconst CarDriver = require('./car-driver');\n\nconst THROTTLE_TIME = 57; // Number of frames it waits before running the maybeSpawn function\nconst SPAWN_PROBABILITY = 0.5;\nconst CARS_PER_ROAD = 0.5;\n\nclass CarSpawner {\n  constructor(carOverlay, config) {\n    this.overlay = carOverlay;\n    this.config = config;\n    this.city = carOverlay.city;\n\n    this.throttleTimer = Math.random() * THROTTLE_TIME;\n    this.setModeDistribution(this.config.traffic['traffic-mode-rates']);\n\n    this.DefaultDriver = CarDriver;\n  }\n\n  /**\n   * Returns of all the texture ids of the cars in the config file\n   */\n  static allTextureIds(config) {\n    const textures = {};\n    Object.entries(config.carTypes).forEach(([id, props]) => {\n      if (props.variants) {\n        Object.assign(textures,\n          Object.fromEntries(props.variants.map(variant => [`${id}-${variant}`, true])));\n      } else {\n        textures[id] = true;\n      }\n\n      if (props.wagons) {\n        Object.assign(textures,\n          Object.fromEntries(props.wagons.flat().map(wagonId => [wagonId, true])));\n      }\n    });\n\n    return Object.keys(textures);\n  }\n\n  setModeDistribution(modeDistribution, tags = []) {\n    this.modeDistribution = modeDistribution;\n    this.modeRandomizer = weightedRandomizer(Object.entries(modeDistribution));\n    this.carRandomizers = Object.fromEntries(Object.keys(modeDistribution).map(mode => [\n      mode, weightedRandomizer(\n        Object.entries(this.config.carTypes)\n          .filter(([, props]) => props.mode === mode)\n          .filter(([, props]) => (\n            (props.include === undefined || props.include.some(tag => tags.includes(tag)))\n            && (props.exclude === undefined || !props.exclude.some(tag => tags.includes(tag)))\n          ))\n          .map(([id, props]) => [id, props.frequency || 1])\n      )]));\n  }\n\n  maybeSpawn() {\n    const maxCars = this.overlay.roads.roadCount() * CARS_PER_ROAD;\n    if (this.overlay.cars.length < maxCars) {\n      if (Math.random() < SPAWN_PROBABILITY) {\n        this.spawn();\n      }\n    }\n  }\n\n  getRandomCarType() {\n    return this.carRandomizers[this.modeRandomizer()]();\n  }\n\n  getRandomTile() {\n    const roadTiles = this.overlay.roads.connectedRoadTiles();\n    if (roadTiles.length === 0) {\n      return null;\n    }\n    const [x, y] = roadTiles[Math.floor(Math.random() * roadTiles.length)];\n    return { x, y };\n  }\n\n  getPreferredDirections(tileX, tileY) {\n    const maxY = (this.city.map.height - 1);\n    const maxX = (this.city.map.width - 1);\n    const distanceFromBorder = [\n      ['N', tileY / maxY],\n      ['E', (maxX - tileX) / maxX],\n      ['S', (maxY - tileY) / maxY],\n      ['W', tileX / maxX],\n    ];\n    return distanceFromBorder\n      .sort((a, b) => a[1] - b[1])\n      .map(a => a[0]);\n  }\n\n  getRandomEntrySide(tileX, tileY) {\n    const validDirections = this.overlay.roads.adjRoadDirs(tileX, tileY);\n    return validDirections.length === 1\n      ? Dir.opposite(validDirections[0])\n      : this.getPreferredDirections(tileX, tileY).find(d => validDirections.includes(d));\n  }\n\n  getRandomLane(carType) {\n    const options = (this.config.carTypes[carType].lanes || 'inner, outer')\n      .split(',')\n      .map(s => RoadTile.laneNames[s.trim().toLowerCase()]);\n\n    return options.length === 1 ? options[0] : randomItem(options);\n  }\n\n  getRandomTexture(carType) {\n    const options = (this.config.carTypes[carType].variants\n      ? this.config.carTypes[carType].variants.map(variant => `${carType}-${variant}`)\n      : [carType]);\n\n    return this.overlay.textures.cars[randomItem(options)];\n  }\n\n  getRandomWagonTextures(carType) {\n    return this.config.carTypes[carType].wagons.map(wagonDef => (\n      Array.isArray(wagonDef) ? randomItem(wagonDef) : wagonDef\n    ));\n  }\n\n  spawn(explicitCarType) {\n    const tile = this.getRandomTile();\n    if (tile) {\n      const entrySide = this.getRandomEntrySide(tile.x, tile.y);\n      const carType = explicitCarType || this.getRandomCarType();\n      const texture = this.getRandomTexture(carType);\n      const lane = this.getRandomLane(carType);\n      // const maxSpeed = this.getRandomMaxSpeed(carType, lane);\n      const maxSpeed = this.config.carTypes[carType].maxSpeed || 1;\n      const isBike = this.config.carTypes[carType].mode === 'bike';\n\n      const car = new Car(\n        this.overlay, texture, tile.x, tile.y, entrySide, lane, maxSpeed,\n        isBike ? CarDriver : this.DefaultDriver\n      );\n      this.overlay.addCar(car);\n\n      if (this.config.carTypes[carType].wagons) {\n        let lastWagon = car;\n        this.getRandomWagonTextures(carType).forEach((wagonTextureId) => {\n          const wagonTexture = this.overlay.textures.cars[wagonTextureId];\n          const wagon = new Car(\n            this.overlay, wagonTexture, tile.x, tile.y, entrySide, lane, maxSpeed\n          );\n          lastWagon.addWagon(wagon);\n          this.overlay.addCar(wagon);\n          lastWagon = wagon;\n        });\n      }\n    }\n  }\n\n  animate(time) {\n    this.throttleTimer += time;\n    if (this.throttleTimer > THROTTLE_TIME) {\n      this.throttleTimer %= THROTTLE_TIME;\n      this.maybeSpawn();\n    }\n  }\n}\n\nmodule.exports = CarSpawner;\n","/* globals PIXI */\nconst Vec2 = require('vec2');\nconst CarDriver = require('./car-driver');\nconst Dir = require('../aux/cardinal-directions');\nconst RoadTile = require('./road-tile');\nconst { TILE_SIZE } = require('../map-view');\nconst SpriteFader = require('../aux/sprite-fader');\nconst PathStraight = require('./path-straight');\nconst PathArc = require('./path-arc');\nconst PulledCarDriver = require('./pulled-car-driver');\n\n// Max lifetime of cars\nconst MAX_LIFETIME = 2 * 60 * 60; // Approx. 2 minutes\nconst MAX_TIME_STOPPED = 60 * 60; // Approx. 1 minute\n\nconst SPRITE_ANCHOR_X = 0.5;\nconst SPRITE_ANCHOR_Y = 0.75;\n\nclass Car {\n  constructor(carOverlay, texture, tileX, tileY, entrySide, lane, maxSpeed = 1, DriverClass = CarDriver) {\n    this.overlay = carOverlay;\n    this.lane = lane;\n    this.maxSpeed = maxSpeed;\n    this.speed = maxSpeed;\n    this.lifetime = 0;\n    this.timeStopped = 0;\n    this.isSpawning = true;\n    this.isDespawning = false;\n    this.frontWagon = null;\n    this.backWagon = null;\n    this.path = null;\n    this.DriverClass = DriverClass;\n\n    this.driver = new this.DriverClass(this);\n\n    this.sprite = Car.createSprite(texture);\n    this.fader = new SpriteFader(this.sprite);\n    this.setTile(tileX, tileY, entrySide);\n    this.setSpritePosition(this.tilePosition().add(RoadTile.entryPoint(this.lane, this.entrySide)));\n    this.sprite.rotation = Dir.asAngle(Dir.opposite(this.entrySide));\n  }\n\n  static createSprite(texture) {\n    const sprite = new PIXI.Sprite();\n    sprite.texture = texture;\n    sprite.width = texture.width;\n    sprite.height = texture.height;\n    // sprite.roundPixels = true;\n    sprite.anchor.set(SPRITE_ANCHOR_X, SPRITE_ANCHOR_Y);\n    sprite.visible = true;\n    sprite.alpha = 0;\n\n    return sprite;\n  }\n\n  destroy() {\n    if (this.backWagon) {\n      this.backWagon.removeFrontWagon();\n    }\n    this.sprite.destroy();\n    this.sprite = null;\n    this.overlay = null;\n  }\n\n  despawn() {\n    if (!this.isDespawning) {\n      this.isDespawning = true;\n      this.fader.fadeOut(() => {\n        this.overlay.onCarExitTile(this, this.tile.x, this.tile.y);\n        this.overlay.onCarExitMap(this);\n      });\n    }\n  }\n\n  despawnWagons() {\n    let nextWagon = this.backWagon;\n    while (nextWagon) {\n      nextWagon.despawn();\n      nextWagon = nextWagon.backWagon;\n    }\n  }\n\n  addWagon(car) {\n    this.backWagon = car;\n    car.frontWagon = this;\n    car.driver = new PulledCarDriver(car);\n  }\n\n  removeFrontWagon() {\n    this.frontWagon = null;\n    this.driver = new this.DriverClass(this);\n  }\n\n  isPulling(car) {\n    let eachCar = this;\n    while (eachCar.backWagon) {\n      if (car === eachCar.backWagon) {\n        return true;\n      }\n      eachCar = eachCar.backWagon;\n    }\n    return false;\n  }\n\n  setTile(x, y, entrySide) {\n    // Check if the coordinates are valid\n    if (!this.overlay.city.map.isValidCoords(x, y)) {\n      this.despawn();\n      return;\n    }\n\n    // Check if the tile has an exit\n    const exitSide = this.driver.chooseExitSide(x, y, entrySide);\n    if (exitSide === null) {\n      this.despawn();\n      return;\n    }\n\n    this.tile = { x, y };\n    this.entrySide = entrySide;\n    this.exitSide = exitSide;\n\n    const remainder = this.path !== null ? this.path.remainder : 0;\n    this.path = this.exitSide === Dir.opposite(this.entrySide)\n      ? new PathStraight(this.lane, this.entrySide)\n      : new PathArc(this.lane, this.entrySide, this.exitSide);\n    this.path.advance(remainder);\n\n    this.onEnterTile();\n  }\n\n  getNextTile() {\n    return Dir.adjCoords(this.tile.x, this.tile.y, this.exitSide);\n  }\n\n  getNextEntry() {\n    return Dir.opposite(this.exitSide);\n  }\n\n  tilePosition() {\n    return Vec2(this.tile.x * TILE_SIZE, this.tile.y * TILE_SIZE);\n  }\n\n  setSpritePosition(v) {\n    this.sprite.x = v.x;\n    this.sprite.y = v.y;\n  }\n\n  getSpritePosition() {\n    return Vec2(this.sprite.x, this.sprite.y);\n  }\n\n  onEnterTile() {\n    this.overlay.onCarEnterTile(this, this.tile.x, this.tile.y);\n  }\n\n  onGreenLight() {\n    this.driver.onGreenLight();\n  }\n\n  onRedLight() {\n    this.driver.onRedLight();\n  }\n\n  onExitTile() {\n    this.overlay.onCarExitTile(this, this.tile.x, this.tile.y);\n\n    // Transfer the car to the next tile\n    this.setTile(...this.getNextTile(), this.getNextEntry());\n  }\n\n  hasCarsOverlapping() {\n    const cheapDistance = (v1, v2) => Math.max(Math.abs(v1.x - v2.x), Math.abs(v1.y - v2.y));\n    const position = this.getSpritePosition();\n    return this.overlay.getCarsAround(this).some((carAround) => {\n      const overlapDistance = this.sprite.height / 2 + carAround.sprite.height / 2;\n      return cheapDistance(carAround.getSpritePosition(), position) < overlapDistance\n        && !this.isPulling(carAround) && !carAround.isPulling(this);\n    });\n  }\n\n  animate(time) {\n    this.driver.adjustCarSpeed();\n\n    if (this.isSpawning && !this.hasCarsOverlapping()\n      && (!this.frontWagon || this.speed > 0)) {\n      this.isSpawning = false;\n    }\n\n    if (this.speed > 0) {\n      this.timeStopped = 0;\n      this.path.advance(this.speed * time);\n      this.setSpritePosition(this.tilePosition().add(this.path.position));\n      this.sprite.rotation = this.path.rotation;\n      if (this.path.progress === 1) {\n        this.onExitTile();\n      }\n    } else {\n      this.timeStopped += time;\n    }\n\n    this.lifetime += time;\n    if (!this.frontWagon) {\n      if ((this.lifetime > MAX_LIFETIME || this.timeStopped > MAX_TIME_STOPPED)\n        && this.overlay.options.maxLifetime) {\n        this.despawn();\n        this.despawnWagons();\n      }\n    }\n\n    if (this.isDespawning\n      || this.isSpawning\n      || !this.overlay.roads.isRoad(this.tile.x, this.tile.y)) {\n      this.fader.fadeOut();\n    } else {\n      this.fader.fadeIn();\n    }\n    this.fader.animate(time);\n  }\n}\n\nmodule.exports = Car;\n","const Vec2 = require('vec2');\nconst Dir = require('../aux/cardinal-directions');\nconst RoadTile = require('./road-tile');\n\nclass PathArc {\n  constructor(lane, entrySide, exitSide) {\n    this.arcRotation = RoadTile.curveRotation(entrySide, exitSide);\n\n    const rotationDir = RoadTile.curveRotDir(entrySide, exitSide);\n    this.rotationSign = rotationDir === 'cw' ? 1 : -1;\n    this.arcRadius = RoadTile.curveRadius[rotationDir][lane];\n    this.arcLength = Math.PI * this.arcRadius / 2;\n    this.rotCenter = RoadTile.curveCenter(entrySide, exitSide);\n\n    this.distance = 0;\n    this.progress = 0;\n    this.remainder = 0;\n    this.position = RoadTile.entryPoint(lane, entrySide);\n  }\n\n  advance(distance) {\n    this.distance += distance;\n    if (this.distance > this.arcLength) {\n      this.remainder = this.distance - this.arcLength;\n      this.distance = this.arcLength;\n    }\n    this.progress = this.distance / this.arcLength;\n    const angle = this.arcRotation + this.progress * (Math.PI / 2) * this.rotationSign;\n    this.position = Vec2(0, this.arcRadius)\n      .rotate(angle)\n      .add(this.rotCenter);\n    this.rotation = angle + Math.PI / 2 * this.rotationSign;\n  }\n}\n\nmodule.exports = PathArc;\n","const Vec2 = require('vec2');\nconst RoadTile = require('./road-tile');\nconst Dir = require('../aux/cardinal-directions');\nconst MapView = require('../map-view');\n\nclass PathStraight {\n  constructor(lane, entrySide) {\n    this.entryPoint = RoadTile.entryPoint(lane, entrySide);\n    this.rotation = Dir.asAngle(Dir.opposite(entrySide));\n\n    this.distance = 0;\n    this.progress = 0;\n    this.remainder = 0;\n    this.position = this.entryPoint;\n  }\n\n  advance(distance) {\n    this.distance += distance;\n    if (this.distance > MapView.TILE_SIZE) {\n      this.remainder = this.distance - MapView.TILE_SIZE;\n      this.distance = MapView.TILE_SIZE;\n    }\n    this.progress = this.distance / MapView.TILE_SIZE;\n\n    this.position = Vec2(0, this.distance).rotate(this.rotation).add(this.entryPoint);\n  }\n}\n\nmodule.exports = PathStraight;\n","const CarDriver = require('./car-driver');\n\nclass PulledCarDriver extends CarDriver {\n  chooseExitSide() {\n    return this.car.frontWagon.exitSide;\n  }\n\n  onGreenLight() {\n\n  }\n\n  onRedLight() {\n\n  }\n\n  adjustCarSpeed() {\n    const position = this.car.getSpritePosition();\n    const { frontWagon } = this.car;\n\n    const overlapDistance = this.car.sprite.height * (1 - this.car.sprite.anchor.y)\n      + (frontWagon.sprite.height * this.car.sprite.anchor.y);\n\n    const distanceToCarInFront = frontWagon\n      .getSpritePosition()\n      .distance(position);\n    if (distanceToCarInFront < overlapDistance - 2) {\n      this.car.speed = 0;\n    } else {\n      // Deaccelerate to maintain the safe distance\n      this.car.speed = frontWagon.speed;\n    }\n  }\n}\n\nmodule.exports = PulledCarDriver;\n","const Dir = require('../aux/cardinal-directions');\nconst Array2D = require('../aux/array-2d');\n\nclass RoadMap {\n  constructor(map, roadTileId) {\n    this.map = map;\n    this.roadTileId = roadTileId;\n  }\n\n  isRoad(x, y) {\n    return !this.map.isValidCoords(x, y)\n      || this.map.get(x, y) === this.roadTileId;\n  }\n\n  hasAdjRoad(x, y, direction) {\n    return this.isRoad(...Dir.adjCoords(x, y, direction));\n  }\n\n  adjRoadDirs(x, y) {\n    return Dir.all.filter(d => this.hasAdjRoad(x, y, d));\n  }\n\n  roadCount() {\n    return Array2D.reduce(this.map.cells,\n      (total, cell) => total + (cell === this.roadTileId ? 1 : 0), 0);\n  }\n\n  roadTiles() {\n    return Array2D.items(this.map.cells).filter(([x, y]) => this.map.get(x, y) === this.roadTileId);\n  }\n\n  connectedRoadTiles() {\n    return this.roadTiles().filter(([x, y]) => this.hasAdjRoad(x, y, 'N')\n      || this.hasAdjRoad(x, y, 'E')\n      || this.hasAdjRoad(x, y, 'S')\n      || this.hasAdjRoad(x, y, 'W'));\n  }\n}\n\nmodule.exports = RoadMap;\n","const Vec2 = require('vec2');\nconst { TILE_SIZE } = require('../map-view');\n\nconst LANE_WIDTH = TILE_SIZE / 6;\n\nconst INNER_LANE = 2;\nconst OUTER_LANE = 1;\nconst BIKE_LANE = 0;\n\nconst laneNames = {\n  inner: INNER_LANE,\n  outer: OUTER_LANE,\n  bike: BIKE_LANE,\n};\n\nfunction entryPoint(lane, side) {\n  switch (side) {\n    case 'W':\n      return Vec2(0, TILE_SIZE - (LANE_WIDTH * (lane + 0.5)));\n    case 'E':\n      return Vec2(TILE_SIZE, LANE_WIDTH * (lane + 0.5));\n    case 'S':\n      return Vec2(TILE_SIZE - (LANE_WIDTH * (lane + 0.5)), TILE_SIZE);\n    case 'N':\n      return Vec2(LANE_WIDTH * (lane + 0.5), 0);\n    default:\n      throw new Error(`Invalid direction ${side}`);\n  }\n}\n\nfunction exitPoint(lane, side) {\n  switch (side) {\n    case 'W':\n      return Vec2(0, LANE_WIDTH * (lane + 0.5));\n    case 'E':\n      return Vec2(TILE_SIZE, TILE_SIZE - (LANE_WIDTH * (lane + 0.5)));\n    case 'S':\n      return Vec2(LANE_WIDTH * (lane + 0.5), TILE_SIZE);\n    case 'N':\n      return Vec2(TILE_SIZE - (LANE_WIDTH * (lane + 0.5)), 0);\n    default:\n      throw new Error(`Invalid direction ${side}`);\n  }\n}\n\nconst curveRadius = {\n  cw: [],\n  ccw: [],\n};\ncurveRadius.cw[BIKE_LANE] = LANE_WIDTH * 0.5;\ncurveRadius.cw[OUTER_LANE] = LANE_WIDTH * 1.5;\ncurveRadius.cw[INNER_LANE] = LANE_WIDTH * 2.5;\ncurveRadius.ccw[INNER_LANE] = LANE_WIDTH * 3.5;\ncurveRadius.ccw[OUTER_LANE] = LANE_WIDTH * 4.5;\ncurveRadius.ccw[BIKE_LANE] = LANE_WIDTH * 5.5;\n\nfunction curveRotDir(entryDir, exitDir) {\n  const table = {\n    N: { W: 'cw', E: 'ccw' },\n    E: { N: 'cw', S: 'ccw' },\n    S: { E: 'cw', W: 'ccw' },\n    W: { S: 'cw', N: 'ccw' },\n  };\n\n  return table[entryDir][exitDir];\n}\n\nfunction curveCenter(entryDir, exitDir) {\n  const ne = Vec2(TILE_SIZE, 0);\n  const se = Vec2(TILE_SIZE, TILE_SIZE);\n  const sw = Vec2(0, TILE_SIZE);\n  const nw = Vec2(0, 0);\n\n  const table = {\n    N: { W: nw, E: ne },\n    E: { N: ne, S: se },\n    S: { E: se, W: sw },\n    W: { S: sw, N: nw },\n  };\n\n  return table[entryDir][exitDir];\n}\n\nfunction curveRotation(entryDir, exitDir) {\n\n  const table = {\n    N: { W: Math.PI * 1.5, E: Math.PI * 0.5 },\n    E: { N: 0, S: Math.PI },\n    S: { E: Math.PI * 0.5, W: Math.PI * 1.5 },\n    W: { S: Math.PI, N: 0 },\n  };\n\n  return table[entryDir][exitDir];\n}\n\nmodule.exports = {\n  BIKE_LANE,\n  OUTER_LANE,\n  INNER_LANE,\n  LANE_WIDTH,\n  laneNames,\n  entryPoint,\n  exitPoint,\n  curveRadius,\n  curveRotDir,\n  curveCenter,\n  curveRotation,\n};\n","const Dir = require('../aux/cardinal-directions');\n\nconst MIN_LIGHT_CHANGE_DELAY = 500;\nconst MAX_LIGHT_CHANGE_DELAY = 1200;\n\nclass TrafficLights {\n  constructor() {\n    this.carsCrossing = [];\n    this.carsWaiting = [];\n    this.greenDirections = [];\n    this.lightsChanging = false;\n  }\n\n  onCarRequestToCross(car) {\n    if (!this.lightsChanging && this.greenDirections.length === 0) {\n      // This criteria to turn on green lights could be different\n      // or more complex. It could be based on the number of\n      // connections the tile has to roads, and the allowed\n      // directions of turns. But maybe this will be enough for now...\n      if (Dir.opposite(car.entrySide) === car.exitSide) {\n        this.greenDirections = [`${car.entrySide}-${car.exitSide}`,\n          `${Dir.opposite(car.entrySide)}-${Dir.opposite(car.exitSide)}`];\n      } else {\n        this.greenDirections = [`${car.entrySide}-${car.exitSide}`,\n          `${car.exitSide}-${car.entrySide}`];\n      }\n    }\n    if (this.greenDirections.includes(`${car.entrySide}-${car.exitSide}`)) {\n      return true;\n    }\n    return false;\n  }\n\n  onCarEnter(car) {\n    if (this.onCarRequestToCross(car)) {\n      this.carsCrossing.push(car);\n    } else {\n      this.carsWaiting.push(car);\n      car.onRedLight();\n    }\n  }\n\n  onCarExit(car) {\n    this.carsCrossing = this.carsCrossing.filter(c => c !== car);\n    this.carsWaiting = this.carsWaiting.filter(c => c !== car);\n    if (this.carsCrossing.length === 0) {\n      this.switchLights();\n    }\n  }\n\n  getRandomLightChangeDelay() {\n    return MIN_LIGHT_CHANGE_DELAY\n      + Math.random() * (MAX_LIGHT_CHANGE_DELAY - MIN_LIGHT_CHANGE_DELAY);\n  }\n\n  switchLights() {\n    this.lightsChanging = true;\n    setTimeout(() => {\n      this.lightsChanging = false;\n      this.greenDirections = [];\n      this.carsWaiting.forEach((car) => {\n        if (this.onCarRequestToCross(car)) {\n          this.carsWaiting = this.carsWaiting.filter(c => c !== car);\n          this.carsCrossing.push(car);\n          car.onGreenLight();\n        }\n      });\n    }, this.getRandomLightChangeDelay());\n  }\n}\n\nmodule.exports = TrafficLights;\n","const Grid = require('./grid');\nconst Array2D = require('./aux/array-2d');\n\nclass City {\n  constructor(width, height, cells = null) {\n    this.map = new Grid(width, height, cells);\n  }\n\n  toJSON() {\n    const { map } = this;\n    return {\n      map: map.toJSON(),\n    };\n  }\n\n  static fromJSON(jsonObject) {\n    const { map } = jsonObject;\n    if (Array.isArray(map)) {\n      // Support old serialization format\n      return new City(16, 16, Array2D.fromFlat(16, 16, map.map(v => Number(v))));\n    }\n    const { width, height } = map;\n\n    // Support old serialization format\n    const cells = Array2D.isValid(map.cells)\n      ? Array2D.clone(map.cells)\n      : Array2D.fromFlat(width, height, map.cells.map(v => Number(v)));\n    return new City(width, height, cells);\n  }\n\n  copy(city) {\n    this.map.copy(city.map);\n  }\n}\n\nmodule.exports = City;\n","class ConnectionStateView {\n  constructor(connector) {\n    this.$element = $('<div></div>')\n      .addClass('connection-state-view');\n\n    this.$errorMessage = $('<div></div>')\n      .addClass('connection-state-view-error text-danger')\n      .appendTo(this.$element);\n    this.$errorStatus = $('<div></div>')\n      .addClass('connection-state-view-status')\n      .appendTo(this.$element);\n\n    connector.events.on('disconnect', this.handleDisconnect.bind(this));\n    connector.events.on('connectWait', this.handleConnectWait.bind(this));\n    connector.events.on('connecting', this.handleConnecting.bind(this));\n    connector.events.on('connect', this.handleConnect.bind(this));\n  }\n\n  show() {\n    this.$element.addClass('visible');\n  }\n\n  hide() {\n    this.$element.removeClass('visible');\n  }\n\n  setErrorMessage(message) {\n    this.$errorMessage.html(message);\n  }\n\n  setErrorStatus(status) {\n    this.$errorStatus.html(status);\n  }\n\n  handleDisconnect() {\n    this.setErrorMessage('Disconnected from server');\n    this.setErrorStatus('');\n    this.show();\n  }\n\n  handleConnectWait() {\n    this.setErrorStatus('Waiting to reconnect...');\n  }\n\n  handleConnecting() {\n    this.setErrorStatus('Connecting...');\n  }\n\n  handleConnect() {\n    this.hide();\n  }\n}\n\nmodule.exports = ConnectionStateView;\n","const EventEmitter = require('events');\nconst Array2D = require('./aux/array-2d');\n\n/**\n * Represents a 2D grid map that stores a single Number per cell\n */\nclass Grid {\n  /**\n   * Create a new grid\n   *\n   * @param {number} width\n   * @param {number} height\n   * @param {number[][]} cells\n   */\n  constructor(width, height, cells = null) {\n    this.width = width;\n    this.height = height;\n    this.cells = cells || Array2D.create(width, height, 0);\n    this.events = new EventEmitter();\n  }\n\n  /**\n   * Create a new Grid from a JSON string\n   *\n   * @param jsonObject {object} JSON object\n   * @return {Grid}\n   */\n  static fromJSON(jsonObject) {\n    const { width, height, cells } = jsonObject;\n    return new Grid(width, height, cells);\n  }\n\n  /**\n   * Serializes to a JSON object\n   * @return {{cells: number[][], width: number, height: number}}\n   */\n  toJSON() {\n    return {\n      width: this.width,\n      height: this.height,\n      cells: Array2D.clone(this.cells),\n    };\n  }\n\n  copy(grid) {\n    this.width = grid.width;\n    this.height = grid.height;\n    this.replace(grid.cells);\n  }\n\n  /**\n   * Retrieves the value at (x,y)\n   *\n   * @param {number} x\n   * @param {number} y\n   * @return {number}\n   */\n  get(x, y) {\n    return this.cells[y][x];\n  }\n\n  /**\n   * Set the value at (x, y)\n   *\n   * @fires Grid.events#update\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} value\n   */\n  set(x, y, value) {\n    this.cells[y][x] = value;\n\n    /**\n     * Update event.\n     *\n     * Argument is an array of updated cells. Each updated cell is represented\n     * by an array with three elements: [x, y, value]\n     *\n     * @event Grid.events#update\n     * @type {[[number, number, number]]}\n     */\n    this.events.emit('update', [[x, y, value]]);\n  }\n\n  /**\n   * Backwards compatibility function that maps (x, y) to a single index in a flat array\n   * @deprecated\n   * @param x {number}\n   * @param y {number}\n   * @return {number}\n   */\n  offset(x, y) {\n    return y * this.width + x;\n  }\n\n  replace(cells) {\n    Array2D.copy(cells, this.cells);\n    this.events.emit('update', this.allCells());\n  }\n\n  /**\n   * Returns true if (x, y) are valid coordinates within the grid's bounds.\n   *\n   * @param {number} x\n   * @param {number} y\n   * @return {boolean}\n   */\n  isValidCoords(x, y) {\n    return x >= 0 && y >= 0 && x < this.width && y < this.height;\n  }\n\n  /**\n   * Returns all cells, represented as [x, y, value] arrays.\n   *\n   * @return {[[number, number, number]]}\n   */\n  allCells() {\n    return Array2D.items(this.cells);\n  }\n\n  /**\n   * Get cells adjacent to the cell at (i, j).\n   *\n   * Each cell is represented by an array of the form [i, j, value]\n   * A cell has at most four adjacent cells, which share one side\n   * (diagonals are not adjacent).\n   *\n   * @param {number} i\n   * @param {number} j\n   * @return {[[number, number, number]]}\n   */\n  adjacentCells(i, j) {\n    return [[i, j - 1], [i + 1, j], [i, j + 1], [i - 1, j]]\n      .filter(([x, y]) => this.isValidCoords(x, y))\n      .map(([x, y]) => [x, y, this.get(x, y)]);\n  }\n\n  /**\n   * Returns the coordinates of cells around the cell at (x, y).\n   *\n   * Each cells returned is represented as an array [x, y].\n   * Cells \"around\" are those reachable by no less than <distance> steps in\n   * any direction, including diagonals.\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} distance\n   * @return {[[number, number]]}\n   */\n  nearbyCoords(x, y, distance) {\n    const coords = [];\n    // Top\n    for (let i = x - distance; i < x + distance; i += 1) {\n      coords.push([i, y - distance]);\n    }\n    // Right\n    for (let i = y - distance; i < y + distance; i += 1) {\n      coords.push([x + distance, i]);\n    }\n    // Bottom\n    for (let i = x + distance; i > x - distance; i -= 1) {\n      coords.push([i, y + distance]);\n    }\n    // Left\n    for (let i = y + distance; i > y - distance; i -= 1) {\n      coords.push([x - distance, i]);\n    }\n\n    return coords\n      .filter(([eachX, eachY]) => this.isValidCoords(eachX, eachY));\n  }\n\n  /**\n   * Returns the cells around the cell at (x, y).\n   *\n   * Each cells returned is represented as an array [x, y, value].\n   * Cells \"around\" are those reachable by no less than <distance> steps in\n   * any direction, including diagonals.\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} distance\n   * @return {[[number, number, number]]}\n   */\n  nearbyCells(x, y, distance = 1) {\n    return this.nearbyCoords(x, y, distance)\n      .map(([nx, ny]) => [nx, ny, this.get(nx, ny)]);\n  }\n\n  /**\n   * Returns the frequency distribution of the values\n   * stored in the cells.\n   *\n   * @return {Object.<string, number>}\n   */\n  frequencyDistribution() {\n    const answer = {};\n    Array2D.forEach(this.cells, (v) => {\n      answer[v] = answer[v] === undefined ? 0 : answer[v] + 1;\n    });\n\n    return answer;\n  }\n}\n\nmodule.exports = Grid;\n","/* globals PIXI */\nconst EventEmitter = require('events');\nconst Array2D = require('./aux/array-2d');\nconst { getTileTypeId } = require('./aux/config-helpers');\nconst PencilCursor = require('../../static/fa/pencil-alt-solid.svg');\n\nclass MapView {\n  constructor(city, config, textures) {\n    this.city = city;\n    this.config = config;\n    this.textures = textures;\n    this.events = new EventEmitter();\n    this.pointerActive = false;\n    this.roadTileId = getTileTypeId(config, 'road');\n    this.parkTileId = getTileTypeId(config, 'park');\n    this.waterTileId = getTileTypeId(config, 'water');\n    this.roadTextureKey = 'roads';\n    this.basicTileRenderers = {};\n\n    this.randomizedTerrain = Array2D.create(this.city.map.width, this.city.map.height);\n    Array2D.fill(this.randomizedTerrain, () => Math.random());\n\n    this.displayObject = new PIXI.Container();\n\n    this.bgTiles = Array2D.create(this.city.map.width, this.city.map.height, null);\n    this.textureTiles = Array2D.create(this.city.map.width, this.city.map.height, null);\n\n    this.city.map.allCells().forEach(([x, y]) => {\n      const bgTile = new PIXI.Graphics();\n      bgTile.x = x * MapView.TILE_SIZE;\n      bgTile.y = y * MapView.TILE_SIZE;\n      this.bgTiles[y][x] = bgTile;\n\n      const textureTile = new PIXI.Sprite();\n      textureTile.x = x * MapView.TILE_SIZE;\n      textureTile.y = y * MapView.TILE_SIZE;\n      textureTile.width = MapView.TILE_SIZE;\n      textureTile.height = MapView.TILE_SIZE;\n      textureTile.roundPixels = true;\n      this.textureTiles[y][x] = textureTile;\n      this.renderTile(x, y);\n    });\n\n    this.zoningLayer = new PIXI.Container();\n    this.zoningLayer.addChild(...Array2D.flatten(this.bgTiles));\n    this.displayObject.addChild(this.zoningLayer);\n    this.tileTextureLayer = new PIXI.Container();\n    this.tileTextureLayer.addChild(...Array2D.flatten(this.textureTiles));\n    this.displayObject.addChild(this.tileTextureLayer);\n    this.overlayContainer = new PIXI.Container();\n    this.displayObject.addChild(this.overlayContainer);\n    this.gridOverlay = this.createGridOverlay();\n    this.displayObject.addChild(this.gridOverlay);\n    if (this.config.mapView && this.config.mapView.gridOverlay) {\n      this.renderGrid(this.config.mapView.gridOverlay);\n    }\n\n    this.city.map.events.on('update', this.handleCityUpdate.bind(this));\n    this.handleCityUpdate(this.city.map.allCells());\n  }\n\n  addOverlay(displayObject) {\n    this.overlayContainer.addChild(displayObject);\n    this.overlayContainer.sortChildren();\n  }\n\n  createGridOverlay() {\n    const overlay = new PIXI.Graphics();\n    overlay.x = 0;\n    overlay.y = 0;\n    overlay.width = this.city.map.width * MapView.TILE_SIZE;\n    overlay.height = this.city.map.height * MapView.TILE_SIZE;\n\n    return overlay;\n  }\n\n  setEditCursor() {\n    Array2D.items(this.bgTiles).forEach(([,, bgTile]) => {\n      bgTile.cursor = `url(${PencilCursor}) 0 20, auto`;\n    });\n  }\n\n  setInspectCursor() {\n    Array2D.items(this.bgTiles).forEach(([,, bgTile]) => {\n      bgTile.cursor = 'crosshair';\n    });\n  }\n\n  enableTileInteractivity() {\n    $(window).on('pointerup', () => { this.pointerActive = false; });\n\n    Array2D.items(this.bgTiles).forEach(([x, y, bgTile]) => {\n      bgTile.interactive = true;\n      bgTile.cursor = `url(${PencilCursor}) 0 20, auto`;\n      bgTile.on('pointerdown', (ev) => {\n        this.pointerActive = true;\n        this.events.emit('action', [x, y], {\n          shiftKey: ev.data.originalEvent.shiftKey,\n        });\n      });\n      bgTile.on('pointerover', (ev) => {\n        if (this.pointerActive) {\n          this.events.emit('action', [x, y], {\n            shiftKey: ev.data.originalEvent.shiftKey,\n          });\n        }\n      });\n    });\n  }\n\n  getBgTile(x, y) {\n    return this.bgTiles[y][x];\n  }\n\n  getTextureTile(x, y) {\n    return this.textureTiles[y][x];\n  }\n\n  renderTile(x, y) {\n    this.renderBasicTile(x, y);\n    if (this.city.map.get(x, y) === this.parkTileId) {\n      this.renderParkTile(x, y);\n    }\n    if (this.city.map.get(x, y) === this.waterTileId) {\n      this.renderWaterTile(x, y);\n    }\n    if (this.city.map.get(x, y) === this.roadTileId) {\n      this.renderRoadTile(x, y);\n    }\n  }\n\n  renderParkTile(x, y) {\n    const textureNumber = 1 + Math.round(this.randomizedTerrain[y][x] * 8);\n    this.getTextureTile(x, y).texture = this.textures.parks[`park-0${textureNumber}`];\n    this.getTextureTile(x, y).visible = true;\n  }\n\n  renderWaterTile(x, y) {\n    const textureNumber = 1 + Math.round(this.randomizedTerrain[y][x] * 8);\n    this.getTextureTile(x, y).texture = this.textures.water[`water-0${textureNumber}`];\n    this.getTextureTile(x, y).visible = true;\n  }\n\n  renderRoadTile(i, j) {\n    const connMask = [[i, j - 1], [i + 1, j], [i, j + 1], [i - 1, j]]\n      .map(([x, y]) => (!this.city.map.isValidCoords(x, y)\n      || this.city.map.get(x, y) === this.roadTileId\n        ? '1' : '0')).join('');\n    this.getTextureTile(i, j).texture = this.textures[this.roadTextureKey][`road${connMask}`];\n    this.getTextureTile(i, j).visible = true;\n  }\n\n  renderBasicTile(i, j) {\n    const tileType = this.config.tileTypes[this.city.map.get(i, j)] || null;\n    if (this.basicTileRenderers[tileType.type]) {\n      this.basicTileRenderers[tileType.type](i, j);\n    } else {\n      this.getBgTile(i, j)\n        .clear()\n        .beginFill(tileType ? Number(`0x${tileType.color.substr(1)}`) : 0, 1)\n        .drawRect(0, 0, MapView.TILE_SIZE, MapView.TILE_SIZE)\n        .endFill();\n    }\n    this.getTextureTile(i, j).visible = false;\n  }\n\n  renderGrid(strokeWidth) {\n    const viewWidth = this.city.map.width * MapView.TILE_SIZE;\n    const viewHeight = this.city.map.height * MapView.TILE_SIZE;\n    this.gridOverlay.clear();\n    this.gridOverlay\n      .lineStyle(strokeWidth / 2, 0, 1, 1)\n      .moveTo(strokeWidth / 2, viewHeight - strokeWidth / 2)\n      .lineTo(strokeWidth / 2, strokeWidth / 2)\n      .lineTo(viewWidth - strokeWidth / 2, strokeWidth / 2)\n      .lineTo(viewWidth - strokeWidth / 2, viewHeight - strokeWidth / 2)\n      .lineTo(strokeWidth / 2, viewHeight - strokeWidth / 2)\n      .lineTo(strokeWidth / 2, viewHeight - strokeWidth);\n\n    this.gridOverlay.lineStyle(strokeWidth, 0, 1);\n    for (let i = 1; i < this.city.map.width; i += 1) {\n      this.gridOverlay.moveTo(i * MapView.TILE_SIZE, strokeWidth / 2)\n        .lineTo(i * MapView.TILE_SIZE, viewHeight - strokeWidth / 2);\n    }\n    for (let i = 1; i < this.city.map.height; i += 1) {\n      this.gridOverlay.moveTo(strokeWidth / 2, i * MapView.TILE_SIZE)\n        .lineTo(viewWidth - strokeWidth / 2, i * MapView.TILE_SIZE);\n    }\n  }\n\n  handleCityUpdate(updates) {\n    updates.forEach(([i, j]) => {\n      this.renderTile(i, j);\n      // Todo: This should be optimized so it's not called twice per frame for the same tile.\n      this.city.map.adjacentCells(i, j)\n        .filter(([x, y]) => this.city.map.get(x, y) === this.roadTileId)\n        .forEach(([x, y]) => this.renderRoadTile(x, y));\n    });\n  }\n\n  showGrid() {\n    this.gridOverlay.visible = true;\n  }\n\n  hideGrid() {\n    this.gridOverlay.visible = false;\n  }\n}\n\nMapView.TILE_SIZE = 72;\n\nmodule.exports = MapView;\n","/* eslint-disable no-unused-vars,class-methods-use-this */\n\nclass PowerUpViewHandler {\n  onEnable(powerUp, activePowerUps) {\n\n  }\n\n  onDisable(powerUp, activePowerUps) {\n\n  }\n\n  onChange(activePowerUps) {\n\n  }\n}\n\nmodule.exports = PowerUpViewHandler;\n","class PowerUpViewMgr {\n  constructor() {\n    this.activePowerUps = [];\n    this.handlers = [];\n  }\n\n  registerHandler(handler) {\n    this.handlers.push(handler);\n  }\n\n  update(activePowerUps) {\n    let changes = false;\n    activePowerUps.forEach((powerUp) => {\n      if (!this.activePowerUps.includes(powerUp)) {\n        this.handleEnable(powerUp, activePowerUps);\n        changes = true;\n      }\n    });\n    this.activePowerUps.forEach((powerUp) => {\n      if (!activePowerUps.includes(powerUp)) {\n        this.handleDisable(powerUp, activePowerUps);\n        changes = true;\n      }\n    });\n\n    if (changes) {\n      this.activePowerUps = activePowerUps;\n      this.handlePowerUpChanges(activePowerUps);\n    }\n  }\n\n  handleEnable(powerUp, activePowerUps) {\n    this.handlers.forEach((handler) => {\n      handler.onEnable(powerUp, activePowerUps);\n    });\n  }\n\n  handleDisable(powerUp, activePowerUps) {\n    this.handlers.forEach((handler) => {\n      handler.onDisable(powerUp, activePowerUps);\n    });\n  }\n\n  handlePowerUpChanges(activePowerUps) {\n    this.handlers.forEach((handler) => {\n      handler.onChange(activePowerUps);\n    });\n  }\n}\n\nmodule.exports = PowerUpViewMgr;\n","const PowerUpViewHandler = require('../power-up-view-handler');\nconst AiCarDriver = require('../cars/ai-car-driver');\n\nclass AutonomousVehicleHandler extends PowerUpViewHandler {\n  constructor(config, carSpawner) {\n    super();\n    this.config = config;\n    this.carSpawner = carSpawner;\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'autonomous-vehicles') {\n      this.previousDefaultDriver = this.carSpawner.DefaultDriver;\n      this.carSpawner.DefaultDriver = AiCarDriver;\n    }\n  }\n\n  onDisable(powerUp) {\n    if (powerUp === 'autonomous-vehicles') {\n      if (this.previousDefaultDriver) {\n        this.carSpawner.DefaultDriver = this.previousDefaultDriver;\n      }\n    }\n  }\n}\n\nmodule.exports = AutonomousVehicleHandler;\n","const PowerUpViewHandler = require('../power-up-view-handler');\nconst MapView = require('../map-view');\nconst { getTileTypeId } = require('../aux/config-helpers');\n\nclass DenseCityHandler extends PowerUpViewHandler {\n  constructor(config, mapView) {\n    super();\n    this.config = config;\n    this.mapView = mapView;\n\n    const residentialId = getTileTypeId(this.config, 'residential');\n    const commercialId = getTileTypeId(this.config, 'commercial');\n\n    this.colors = {\n      residential: this.config.tileTypes[residentialId].color,\n      commercial: this.config.tileTypes[commercialId].color,\n    };\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'dense-city') {\n      this.mapView.basicTileRenderers.residential = this.renderResidential.bind(this);\n      this.mapView.basicTileRenderers.commercial = this.renderCommercial.bind(this);\n      this.mapView.handleCityUpdate(this.mapView.city.map.allCells());\n    }\n  }\n\n  onDisable(powerUp) {\n    if (powerUp === 'dense-city') {\n      this.mapView.basicTileRenderers.residential = null;\n      this.mapView.basicTileRenderers.commercial = null;\n      this.mapView.handleCityUpdate(this.mapView.city.map.allCells());\n    }\n  }\n\n  renderResidential(i, j) {\n    this.mapView.getBgTile(i, j)\n      .clear()\n      .beginFill(Number(`0x${this.colors.residential.substr(1)}`), 1)\n      .drawRect(0, 0, MapView.TILE_SIZE, MapView.TILE_SIZE)\n      .beginFill(Number(`0x${this.colors.commercial.substr(1)}`), 1)\n      .drawRect(MapView.TILE_SIZE / 2, MapView.TILE_SIZE / 2,\n        MapView.TILE_SIZE / 2, MapView.TILE_SIZE / 2)\n      .endFill();\n  }\n\n  renderCommercial(i, j) {\n    this.mapView.getBgTile(i, j)\n      .clear()\n      .beginFill(Number(`0x${this.colors.commercial.substr(1)}`), 1)\n      .drawRect(0, 0, MapView.TILE_SIZE, MapView.TILE_SIZE)\n      .beginFill(Number(`0x${this.colors.residential.substr(1)}`), 1)\n      .drawRect(MapView.TILE_SIZE / 2, MapView.TILE_SIZE / 2,\n        MapView.TILE_SIZE / 2, MapView.TILE_SIZE / 2)\n      .endFill();\n  }\n}\n\nmodule.exports = DenseCityHandler;\n","const PowerUpViewHandler = require('../power-up-view-handler');\n\nclass MaxSpeedHandler extends PowerUpViewHandler {\n  constructor(config, carOverlay) {\n    super();\n    this.config = config;\n    this.carOverlay = carOverlay;\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'reduced-speed-limit') {\n      this.previousMaxSpeed = this.carOverlay.cityMaxSpeed;\n      this.carOverlay.cityMaxSpeed = 0.4;\n    }\n  }\n\n  onDisable(powerUp) {\n    if (powerUp === 'reduced-speed-limit') {\n      this.carOverlay.cityMaxSpeed = (this.previousMaxSpeed || 0.7);\n    }\n  }\n}\n\nmodule.exports = MaxSpeedHandler;\n","const PowerUpViewHandler = require('../power-up-view-handler');\n\nclass SpawnTramHandler extends PowerUpViewHandler {\n  constructor(config, carSpawner) {\n    super();\n    this.config = config;\n    this.carSpawner = carSpawner;\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'improved-mass-transit') {\n      this.carSpawner.spawn('tram');\n      this.carSpawner.spawn('tram');\n    }\n  }\n}\n\nmodule.exports = SpawnTramHandler;\n","const PowerUpViewHandler = require('../power-up-view-handler');\n\nclass TrafficHandler extends PowerUpViewHandler {\n  constructor(config, carSpawner) {\n    super();\n    this.config = config;\n    this.carSpawner = carSpawner;\n  }\n\n  onChange(activePowerUps) {\n    const distribution = Object.assign({}, this.config.traffic['traffic-mode-rates']);\n\n    activePowerUps.forEach((powerUp) => {\n      if (this.config.powerUps[powerUp]['traffic-mode-change']) {\n        Object.entries(this.config.powerUps[powerUp]['traffic-mode-change'])\n          .forEach(([mode, delta]) => {\n            if (distribution[mode] !== undefined) {\n              distribution[mode] += delta;\n            }\n          });\n      }\n    });\n\n    this.carSpawner.setModeDistribution(distribution, activePowerUps);\n  }\n}\n\nmodule.exports = TrafficHandler;\n","const PowerUpViewHandler = require('../power-up-view-handler');\n\nclass WalkableCityHandler extends PowerUpViewHandler {\n  constructor(config, mapView) {\n    super();\n    this.config = config;\n    this.mapView = mapView;\n  }\n\n  onEnable(powerUp) {\n    if (powerUp === 'walkable-city') {\n      this.mapView.roadTextureKey = 'roads-walkable';\n      this.mapView.handleCityUpdate(this.mapView.city.map.allCells());\n    }\n  }\n\n  onDisable(powerUp) {\n    if (powerUp === 'walkable-city') {\n      this.mapView.roadTextureKey = 'roads';\n      this.mapView.handleCityUpdate(this.mapView.city.map.allCells());\n    }\n  }\n}\n\nmodule.exports = WalkableCityHandler;\n","/* eslint-disable no-console */\nconst EventEmitter = require('events');\n\nconst PING_TIME = 1000 * 10;\nconst PONG_WAIT_TIME = 1000 * 10;\nconst RECONNECT_TIME = 1000 * 5;\n\nclass ServerSocketConnector {\n  constructor(uri) {\n    this.uri = uri;\n    this.ws = null;\n    this.connected = false;\n    this.events = new EventEmitter();\n    this.pingTimeout = null;\n    this.pongWaitTimeout = null;\n    this.reconnectTimeout = null;\n    this.connect();\n  }\n\n  connect() {\n    this.cancelPing();\n    this.cancelReconnect();\n\n    this.events.emit('connecting');\n    console.log(`Connecting to ${this.uri}...`);\n    this.ws = new WebSocket(this.uri);\n    this.ws.onopen = this.handleOpen.bind(this);\n    this.ws.onclose = this.handleClose.bind(this);\n    this.ws.onmessage = this.handleMessage.bind(this);\n    // ws.onerror is not handled because the event gives no data about the\n    // error, and on a connection failure onclose will be called.\n\n    this.connected = false;\n  }\n\n  cancelReconnect() {\n    if (this.reconnectTimeout !== null) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n  }\n\n  reconnect() {\n    this.cancelReconnect();\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTimeout = null;\n      this.connect();\n    }, RECONNECT_TIME);\n    this.events.emit('connectWait');\n    console.log(`Will attempt to reconnect in ${RECONNECT_TIME / 1000} seconds...`);\n  }\n\n  handleOpen() {\n    this.cancelReconnect();\n\n    this.connected = true;\n    console.log('Connected.');\n    this.events.emit('connect');\n    this.schedulePing();\n  }\n\n  handleClose(ev) {\n    this.connected = false;\n    this.cancelPing();\n    // ev.code is defined here https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n    // but according to people the only code one normally gets is 1006 (Abnormal Closure)\n    console.error(\n      `Disconnected with code ${ev.code}`,\n      ev.code === 1006 ? ': Abnormal closure' : '',\n      ev.reason ? `(reason: ${ev.reason})` : ''\n    );\n    this.events.emit('disconnect');\n    this.reconnect();\n  }\n\n  handleMessage(ev) {\n    const message = JSON.parse(ev.data);\n    if (message.type === 'map_update') {\n      this.events.emit('map_update', message.cells);\n    } else if (message.type === 'vars_update') {\n      this.events.emit('vars_update', message.variables);\n    } else if (message.type === 'goals_update') {\n      this.events.emit('goals_update', message.goals);\n    } else if (message.type === 'view_show_map_var') {\n      this.events.emit('view_show_map_var', message.variable, message.data);\n    } else if (message.type === 'power_ups_update') {\n      this.events.emit('power_ups_update', message.powerUps);\n    } else if (message.type === 'pong') {\n      this.handlePong();\n    }\n  }\n\n  handlePong() {\n    this.cancelPongWait();\n  }\n\n  send(data) {\n    this.cancelPing();\n    const message = typeof data === 'string' ? { type: data } : data;\n    this.ws.send(JSON.stringify(message));\n    this.schedulePing();\n  }\n\n  cancelPing() {\n    if (this.pingTimeout !== null) {\n      clearTimeout(this.pingTimeout);\n      this.pingTimeout = null;\n    }\n  }\n\n  schedulePing() {\n    this.cancelPing();\n    this.pingTimeout = setTimeout(() => {\n      this.pingTimeout = null;\n      this.ping();\n    }, PING_TIME);\n  }\n\n  cancelPongWait() {\n    if (this.pongWaitTimeout !== null) {\n      clearTimeout(this.pongWaitTimeout);\n      this.pongWaitTimeout = null;\n    }\n  }\n\n  startPongWait() {\n    this.pongWaitTimeout = setTimeout(() => {\n      this.pongWaitTimeout = null;\n      console.warn(`PONG not received after ${PONG_WAIT_TIME / 1000} seconds`);\n      console.warn('Closing connection');\n      this.ws.close();\n    }, PONG_WAIT_TIME);\n  }\n\n  ping() {\n    this.send('ping');\n    this.startPongWait();\n  }\n\n  getMap() {\n    this.send('get_map');\n  }\n\n  setMap(cells) {\n    this.send({\n      type: 'set_map',\n      cells,\n    });\n  }\n\n  getVars() {\n    this.send('get_vars');\n  }\n\n  getGoals() {\n    this.send('get_goals');\n  }\n\n  viewShowMapVariable(variable) {\n    this.send({\n      type: 'view_show_map_var',\n      variable,\n    });\n  }\n\n  enablePowerUp(powerUpId) {\n    this.send({\n      type: 'enable_power_up',\n      powerUpId,\n    });\n  }\n\n  disablePowerUp(powerUpId) {\n    this.send({\n      type: 'disable_power_up',\n      powerUpId,\n    });\n  }\n\n  getActivePowerUps() {\n    this.send('get_active_power_ups');\n  }\n}\n\nmodule.exports = ServerSocketConnector;\n","/* globals PIXI */\n\nclass TextureLoader {\n  constructor(app) {\n    this.app = app;\n    this.errors = [];\n    this.textures = {};\n\n    // Add a pre-load middleware that does cache-busting\n    app.loader.pre((resource, next) => { resource.url += `?t=${Date.now()}`; next(); });\n\n    // Add a post-load middleware that sets the scale mode\n    app.loader.use((resource, next) => {\n      if (resource.texture !== undefined) {\n        resource.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\n      }\n      if (resource.textures !== undefined) {\n        Object.keys(resource.textures).forEach((id) => {\n          resource.textures[id].baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\n        });\n      }\n      next();\n    });\n\n    app.loader.onError.add((err, loader, resource) => {\n      this.errors.push(`${err.message} (${resource.url})`);\n    });\n  }\n\n  addSpritesheet(name) {\n    this.app.loader.add(`./textures/${name}.json`, (resource) => {\n      this.textures[name] = resource.textures;\n    });\n  }\n\n  addFolder(name, keys) {\n    keys.forEach((key) => {\n      this.app.loader.add(key, `./textures/${name}/${key}.png`, (resource) => {\n        if (this.textures[name] === undefined) {\n          this.textures[name] = {};\n        }\n        this.textures[name][key] = resource.texture;\n      });\n    });\n  }\n\n  load() {\n    this.errors = [];\n    return new Promise((resolve, reject) => {\n      this.app.loader.load(() => {\n        if (this.errors.length > 0) {\n          reject(new Error(this.errors.join('<br>')));\n        } else {\n          resolve(this.textures);\n        }\n      });\n    });\n  }\n}\n\nmodule.exports = TextureLoader;\n","const VariableMapView = require('./variable-map-view');\n\nclass VariableMapOverlayTransition {\n  constructor(duration, inView, outView, onCompleteCallback) {\n    this.duration = duration;\n    this.elapsed = 0;\n    this.inView = inView;\n    this.outView = outView;\n    this.onCompletCallback = onCompleteCallback;\n    this.finished = false;\n  }\n\n  animate(time) {\n    if (!this.finished) {\n      this.elapsed += time;\n\n      this.outView.alpha = 1 - Math.min(this.elapsed / this.duration, 1);\n      this.inView.alpha = Math.min(this.elapsed / this.duration, 1);\n      if (this.elapsed > this.duration) {\n        this.finished = true;\n        this.onCompletCallback();\n      }\n    }\n  }\n\n  finish() {\n    if (!this.finished) {\n      this.elapsed = this.duration;\n      this.outView.alpha = 0;\n      this.inView.alpha = 1;\n      this.finished = true;\n      this.onCompletCallback();\n    }\n  }\n}\n\nclass VariableMapOverlay {\n  constructor(mapView, config) {\n    this.mapView = mapView;\n    this.config = config;\n\n    this.transition = null;\n    const parentBounds = mapView.displayObject.getLocalBounds();\n    this.view = new VariableMapView(\n      mapView.city.map.width,\n      mapView.city.map.height\n    );\n    this.view.displayObject.width = parentBounds.width;\n    this.view.displayObject.height = parentBounds.height;\n    this.view.displayObject.zIndex = 200;\n    this.view.displayObject.alpha = 0;\n\n    this.mapView.addOverlay(this.view.displayObject);\n  }\n\n  show(data, color) {\n    if (this.transition !== null) {\n      this.transition.finish();\n    }\n    this.view.update(data, color);\n    this.transition = new VariableMapOverlayTransition(\n      this.config.variableMapOverlay.transitionDuration * 60,\n      this.view.displayObject,\n      this.mapView.zoningLayer,\n      () => {\n        this.transition = null;\n      }\n    );\n  }\n\n  hide() {\n    if (this.transition) {\n      this.transition.finish();\n    }\n    this.transition = new VariableMapOverlayTransition(\n      this.config.variableMapOverlay.transitionDuration * 60,\n      this.mapView.zoningLayer,\n      this.view.displayObject,\n      () => {\n        this.transition = null;\n      }\n    );\n  }\n\n  animate(time) {\n    if (this.transition !== null) {\n      this.transition.animate(time);\n    }\n  }\n}\n\nmodule.exports = VariableMapOverlay;\n","/* globals PIXI */\nconst Array2D = require('./aux/array-2d');\n\nconst TILE_SIZE = 10;\n\nclass VariableMapView {\n  constructor(width, height, defaultColor = 0xff0000) {\n    this.displayObject = new PIXI.Container();\n    this.defaultColor = defaultColor;\n    this.tiles = Array2D.create(width, height, null);\n    this.values = Array2D.create(width, height, 0);\n    this.lastColor = null;\n\n    Array2D.fill(this.tiles, (x, y) => {\n      const newTile = new PIXI.Graphics();\n      newTile.x = x * TILE_SIZE;\n      newTile.y = y * TILE_SIZE;\n      return newTile;\n    });\n\n    this.displayObject.addChild(...Array2D.flatten(this.tiles));\n    Array2D.forEach(this.values, (value, x, y) => {\n      this.renderTile(x, y);\n    });\n  }\n\n  renderTile(x, y, color) {\n    this.tiles[y][x]\n      .clear()\n      .beginFill(color, this.values[y][x] * 0.95)\n      .drawRect(0, 0, TILE_SIZE, TILE_SIZE)\n      .endFill();\n  }\n\n  update(data, color = null) {\n    Array2D.zip(this.values, data, (value, newValue, x, y) => {\n      if (value !== newValue || color !== this.lastColor) {\n        this.values[y][x] = newValue;\n        this.renderTile(x, y, color || this.defaultColor);\n      }\n    });\n    this.lastColor = color;\n  }\n}\n\nmodule.exports = VariableMapView;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","/* eslint-disable no-console */\n/* globals PIXI */\nconst City = require('./city');\nconst MapView = require('./map-view');\nrequire('../sass/default.scss');\nconst ServerSocketConnector = require('./server-socket-connector');\nconst ConnectionStateView = require('./connection-state-view');\nconst showFatalError = require('./aux/show-fatal-error');\nconst CarOverlay = require('./cars/car-overlay');\nconst TextureLoader = require('./texture-loader');\nconst CarSpawner = require('./cars/car-spawner');\nconst VariableMapOverlay = require('./variable-map-overlay');\nconst PowerUpViewMgr = require('./power-up-view-mgr');\nconst TrafficHandler = require('./power-ups/traffic-handler');\nconst AutonomousVehicleHandler = require('./power-ups/autonomous-vehicle-handler');\nconst MaxSpeedHandler = require('./power-ups/max-speed-handler');\nconst SpawnTramHandler = require('./power-ups/spawn-tram');\nconst WalkableCityHandler = require('./power-ups/walkable-city-handler');\nconst DenseCityHandler = require('./power-ups/dense-city-handler');\n\nfetch(`${process.env.SERVER_HTTP_URI}/config`, { cache: 'no-store' })\n  .then(response => response.json())\n  .then((config) => {\n    const city = new City(config.cityWidth, config.cityHeight);\n\n    const app = new PIXI.Application({\n      width: 1152,\n      height: 1152,\n      backgroundColor: 0xf2f2f2,\n    });\n    const textureLoader = new TextureLoader(app);\n    textureLoader.addSpritesheet('roads');\n    textureLoader.addSpritesheet('roads-walkable');\n    textureLoader.addSpritesheet('parks');\n    textureLoader.addSpritesheet('water');\n    textureLoader.addFolder('cars', CarSpawner.allTextureIds(config));\n    textureLoader.load()\n      .then((textures) => {\n        $('[data-component=\"app-container\"]').append(app.view);\n\n        const mapView = new MapView(city, config, textures);\n        app.stage.addChild(mapView.displayObject);\n        mapView.displayObject.width = 1152;\n        mapView.displayObject.height = 1152;\n        mapView.displayObject.x = 0;\n        mapView.displayObject.y = 0;\n\n        const carOverlay = new CarOverlay(mapView, config, textures);\n        app.ticker.add(time => carOverlay.animate(time));\n        const carSpawner = new CarSpawner(carOverlay, config);\n        app.ticker.add(time => carSpawner.animate(time));\n\n        const powerUpViewMgr = new PowerUpViewMgr();\n        powerUpViewMgr.registerHandler(new TrafficHandler(config, carSpawner));\n        powerUpViewMgr.registerHandler(new AutonomousVehicleHandler(config, carSpawner));\n        powerUpViewMgr.registerHandler(new MaxSpeedHandler(config, carOverlay));\n        powerUpViewMgr.registerHandler(new SpawnTramHandler(config, carSpawner));\n        powerUpViewMgr.registerHandler(new WalkableCityHandler(config, mapView));\n        powerUpViewMgr.registerHandler(new DenseCityHandler(config, mapView));\n\n        const variableMapOverlay = new VariableMapOverlay(mapView, config);\n        app.ticker.add(time => variableMapOverlay.animate(time));\n\n        const connector = new ServerSocketConnector(process.env.SERVER_SOCKET_URI);\n        connector.events.on('map_update', (cells) => {\n          city.map.replace(cells);\n        });\n        connector.events.on('connect', () => {\n          connector.getMap();\n          connector.getActivePowerUps();\n        });\n        connector.events.on('view_show_map_var', (variable, data) => {\n          variableMapOverlay.show(data,\n            config.variableMapOverlay.colors[variable] || 0x000000);\n          setTimeout(() => {\n            variableMapOverlay.hide();\n          }, config.variableMapOverlay.overlayDuration * 1000);\n        });\n        connector.events.on('power_ups_update', (activePowerUps) => {\n          powerUpViewMgr.update(activePowerUps);\n        });\n\n        const connStateView = new ConnectionStateView(connector);\n        $('body').append(connStateView.$element);\n      })\n      .catch((err) => {\n        showFatalError('Error loading textures', err);\n      });\n  })\n  .catch((err) => {\n    showFatalError(`Error loading configuration from ${process.env.SERVER_HTTP_URI}`, err);\n    console.error(`Error loading configuration from ${process.env.SERVER_HTTP_URI}`);\n    console.error(err);\n  });\n"],"sourceRoot":""}